{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Start here \u26a0 Important deprecation note \u73fe\u5728\u306e circom \u306fRust\u3067\u66f8\u304b\u308c\u305f\u30b3\u30f3\u30d1\u30a4\u30e9\u3067\u3059\u3002JavaScript\u3067\u66f8\u304b\u308c\u305f\u65e7 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u5c06\u6765\u7684\u306b\u51cd\u7d50\u3055\u308c\u307e\u3059\u304c\u3001 \u53e4\u3044circom\u30ea\u30dd\u30b8\u30c8\u30ea \u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002 About the circom ecosystem circom\u30b3\u30f3\u30d1\u30a4\u30e9\u3068\u305d\u306e\u30a8\u30b3\u30b7\u30b9\u30c6\u30e0\u306b\u3088\u308a\u3001\u56de\u8def\u306e\u4f5c\u6210\u3001\u30c6\u30b9\u30c8\u3001\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306e\u4f5c\u6210\u304c\u53ef\u80fd\u3067\u3059\u3002 circom circom \u306f\u3001 circom \u8a00\u8a9e\u3067\u66f8\u304b\u308c\u305f\u56de\u8def\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u305f\u3081\u306eRust\u3067\u66f8\u304b\u308c\u305f\u30b3\u30f3\u30d1\u30a4\u30e9\u3067\u3059\u3002 \u3053\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u3001\u56de\u8def\u306e\u8868\u73fe\u3092\u5236\u7d04\u3068\u3057\u3066\u51fa\u529b\u3057\u3001\u7570\u306a\u308bZK\u8a3c\u660e\u3092\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u3059\u3079\u3066\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 circomlib circom \u3067\u306f\u3001 templates \u3068\u547c\u3070\u308c\u308b\u5c0f\u3055\u306a\u6c4e\u7528\u56de\u8def\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u3053\u3068\u3067\u3001\u5927\u898f\u6a21\u306a\u56de\u8def\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002 circomlib \u306f circom \u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u30e9\u30a4\u30d6\u30e9\u30ea\u5316\u3057\u305f\u3082\u306e\u3067\u3001comparator\u3001\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3001\u30c7\u30b8\u30bf\u30eb\u7f72\u540d\u30012\u9032\u30fb10\u9032\u5909\u63db\u5668\u306a\u3069\u3001\u6570\u767e\u7a2e\u985e\u306e\u56de\u8def\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\u3002\u72ec\u81ea\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u304c\u3001\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3092\u59cb\u3081\u308b\u524d\u306b\u3001\u3059\u3067\u306b\u4f5c\u6210\u3055\u308c\u3066\u3044\u308b\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u3054\u89a7\u306b\u306a\u308b\u3053\u3068\u3092\u304a\u52e7\u3081\u3057\u307e\u3059\u3002 \u3053\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u306f\u3001 circomlib \u3067\u5229\u7528\u53ef\u80fd\u306a\u56de\u8def\u306e\u30c6\u30b9\u30c8\u304c\u65e2\u306b\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002 \u307e\u305f\u3001\u3053\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u306f\u3001\u4f9d\u5b58\u95a2\u4fc2\u3068\u3057\u3066 npm \u30d1\u30c3\u30b1\u30fc\u30b8 circomlibjs \u3001 circom_tester \u3001 ffjavascript \u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u307e\u3059\u3002 circomlibjs circomlibjs \u306f\u3001 circomlib \u306e\u3044\u304f\u3064\u304b\u306e\u56de\u8def\u306ewitness\u3092\u8a08\u7b97\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u63d0\u4f9b\u3059\u308bJavascript\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u3002 \u3053\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u306f\u3001 circom \u3067\u751f\u6210\u3055\u308c\u305fwasm\u3084c\u30b3\u30fc\u30c9\u3092\u4f7f\u3063\u3066 circomlib \u306e\u591a\u304f\u306e\u56de\u8def\u304b\u3089\u8a08\u7b97\u3055\u308c\u305fwitness\u304c circom \u3067\u751f\u6210\u3055\u308c\u305fwasm\u307e\u305f\u306fc\u30b3\u30fc\u30c9\u3092\u4f7f\u3063\u3066 circomlib \u3067\u751f\u6210\u3055\u308c\u305f\u591a\u304f\u306e\u56de\u8def\u304c\u3001 circomlibjs \u306e\u5bfe\u5fdc\u3059\u308bJavaScript\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u751f\u6210\u3055\u308c\u305f\u3082\u306e\u3068\u4e00\u81f4\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3059\u308b\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002 \u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u306f\u3001\u3053\u308c\u3089\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u304csrc\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002 test\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u306f\u3001\u305d\u308c\u81ea\u8eab\u306e\u30c6\u30b9\u30c8\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002tools\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u306f\u3001\u3044\u304f\u3064\u304b\u306e\u5fc5\u8981\u306a\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4e8b\u524d\u306b\u8a08\u7b97\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002 circom_tester circomtester \u306f\u3001 circom \u306e\u56de\u8def\u3092\u30c6\u30b9\u30c8\u3059\u308b\u305f\u3081\u306e\u30c4\u30fc\u30eb\u3092\u63d0\u4f9b\u3059\u308bnpm\u30d1\u30c3\u30b1\u30fc\u30b8\u3067\u3059\u3002 ffjavascript ffjavascript \u306f\u3001Javascript\u3067\u6709\u9650\u4f53\u6f14\u7b97\u3092\u884c\u3046\u305f\u3081\u306e\u30b3\u30fc\u30c9\u3092npm\u3067\u30d1\u30c3\u30b1\u30fc\u30b8\u5316\u3057\u305f\u3082\u306e\u3067\u3059\u3002 snarkjs snarkjs \u306f\u3001 circom \u3067\u751f\u6210\u3055\u308c\u305f\u30a2\u30fc\u30c6\u30a3\u30d5\u30a1\u30af\u30c8\u304b\u3089ZK\u8a3c\u660e\u3092\u751f\u6210\u30fb\u691c\u8a3c\u3059\u308b\u30b3\u30fc\u30c9\u3092\u542b\u3080npm\u30d1\u30c3\u30b1\u30fc\u30b8\u3067\u3059\u3002 Visual summary","title":"Home"},{"location":"#start-here","text":"","title":"Start here"},{"location":"#important-deprecation-note","text":"\u73fe\u5728\u306e circom \u306fRust\u3067\u66f8\u304b\u308c\u305f\u30b3\u30f3\u30d1\u30a4\u30e9\u3067\u3059\u3002JavaScript\u3067\u66f8\u304b\u308c\u305f\u65e7 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u5c06\u6765\u7684\u306b\u51cd\u7d50\u3055\u308c\u307e\u3059\u304c\u3001 \u53e4\u3044circom\u30ea\u30dd\u30b8\u30c8\u30ea \u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002","title":"&#9888; Important deprecation note"},{"location":"#about-the-circom-ecosystem","text":"circom\u30b3\u30f3\u30d1\u30a4\u30e9\u3068\u305d\u306e\u30a8\u30b3\u30b7\u30b9\u30c6\u30e0\u306b\u3088\u308a\u3001\u56de\u8def\u306e\u4f5c\u6210\u3001\u30c6\u30b9\u30c8\u3001\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306e\u4f5c\u6210\u304c\u53ef\u80fd\u3067\u3059\u3002","title":"About the circom ecosystem"},{"location":"#circom","text":"circom \u306f\u3001 circom \u8a00\u8a9e\u3067\u66f8\u304b\u308c\u305f\u56de\u8def\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u305f\u3081\u306eRust\u3067\u66f8\u304b\u308c\u305f\u30b3\u30f3\u30d1\u30a4\u30e9\u3067\u3059\u3002 \u3053\u306e\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u3001\u56de\u8def\u306e\u8868\u73fe\u3092\u5236\u7d04\u3068\u3057\u3066\u51fa\u529b\u3057\u3001\u7570\u306a\u308bZK\u8a3c\u660e\u3092\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u3059\u3079\u3066\u3092\u51fa\u529b\u3057\u307e\u3059\u3002","title":"circom"},{"location":"#circomlib","text":"circom \u3067\u306f\u3001 templates \u3068\u547c\u3070\u308c\u308b\u5c0f\u3055\u306a\u6c4e\u7528\u56de\u8def\u3092\u7d44\u307f\u5408\u308f\u305b\u308b\u3053\u3068\u3067\u3001\u5927\u898f\u6a21\u306a\u56de\u8def\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3059\u3002 circomlib \u306f circom \u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u30e9\u30a4\u30d6\u30e9\u30ea\u5316\u3057\u305f\u3082\u306e\u3067\u3001comparator\u3001\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3001\u30c7\u30b8\u30bf\u30eb\u7f72\u540d\u30012\u9032\u30fb10\u9032\u5909\u63db\u5668\u306a\u3069\u3001\u6570\u767e\u7a2e\u985e\u306e\u56de\u8def\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\u3002\u72ec\u81ea\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u304c\u3001\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3092\u59cb\u3081\u308b\u524d\u306b\u3001\u3059\u3067\u306b\u4f5c\u6210\u3055\u308c\u3066\u3044\u308b\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u3054\u89a7\u306b\u306a\u308b\u3053\u3068\u3092\u304a\u52e7\u3081\u3057\u307e\u3059\u3002 \u3053\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u306f\u3001 circomlib \u3067\u5229\u7528\u53ef\u80fd\u306a\u56de\u8def\u306e\u30c6\u30b9\u30c8\u304c\u65e2\u306b\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002 \u307e\u305f\u3001\u3053\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u306f\u3001\u4f9d\u5b58\u95a2\u4fc2\u3068\u3057\u3066 npm \u30d1\u30c3\u30b1\u30fc\u30b8 circomlibjs \u3001 circom_tester \u3001 ffjavascript \u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u307e\u3059\u3002","title":"circomlib"},{"location":"#circomlibjs","text":"circomlibjs \u306f\u3001 circomlib \u306e\u3044\u304f\u3064\u304b\u306e\u56de\u8def\u306ewitness\u3092\u8a08\u7b97\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u63d0\u4f9b\u3059\u308bJavascript\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\u3002 \u3053\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u306f\u3001 circom \u3067\u751f\u6210\u3055\u308c\u305fwasm\u3084c\u30b3\u30fc\u30c9\u3092\u4f7f\u3063\u3066 circomlib \u306e\u591a\u304f\u306e\u56de\u8def\u304b\u3089\u8a08\u7b97\u3055\u308c\u305fwitness\u304c circom \u3067\u751f\u6210\u3055\u308c\u305fwasm\u307e\u305f\u306fc\u30b3\u30fc\u30c9\u3092\u4f7f\u3063\u3066 circomlib \u3067\u751f\u6210\u3055\u308c\u305f\u591a\u304f\u306e\u56de\u8def\u304c\u3001 circomlibjs \u306e\u5bfe\u5fdc\u3059\u308bJavaScript\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u751f\u6210\u3055\u308c\u305f\u3082\u306e\u3068\u4e00\u81f4\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u78ba\u8a8d\u3059\u308b\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002 \u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u306f\u3001\u3053\u308c\u3089\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u304csrc\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002 test\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u306f\u3001\u305d\u308c\u81ea\u8eab\u306e\u30c6\u30b9\u30c8\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002tools\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u306f\u3001\u3044\u304f\u3064\u304b\u306e\u5fc5\u8981\u306a\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4e8b\u524d\u306b\u8a08\u7b97\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u304c\u542b\u307e\u308c\u3066\u3044\u307e\u3059\u3002","title":"circomlibjs"},{"location":"#circom_tester","text":"circomtester \u306f\u3001 circom \u306e\u56de\u8def\u3092\u30c6\u30b9\u30c8\u3059\u308b\u305f\u3081\u306e\u30c4\u30fc\u30eb\u3092\u63d0\u4f9b\u3059\u308bnpm\u30d1\u30c3\u30b1\u30fc\u30b8\u3067\u3059\u3002","title":"circom_tester"},{"location":"#ffjavascript","text":"ffjavascript \u306f\u3001Javascript\u3067\u6709\u9650\u4f53\u6f14\u7b97\u3092\u884c\u3046\u305f\u3081\u306e\u30b3\u30fc\u30c9\u3092npm\u3067\u30d1\u30c3\u30b1\u30fc\u30b8\u5316\u3057\u305f\u3082\u306e\u3067\u3059\u3002","title":"ffjavascript"},{"location":"#snarkjs","text":"snarkjs \u306f\u3001 circom \u3067\u751f\u6210\u3055\u308c\u305f\u30a2\u30fc\u30c6\u30a3\u30d5\u30a1\u30af\u30c8\u304b\u3089ZK\u8a3c\u660e\u3092\u751f\u6210\u30fb\u691c\u8a3c\u3059\u308b\u30b3\u30fc\u30c9\u3092\u542b\u3080npm\u30d1\u30c3\u30b1\u30fc\u30b8\u3067\u3059\u3002","title":"snarkjs"},{"location":"#visual-summary","text":"","title":"Visual summary "},{"location":"background/background/","text":"Background Zero-knowledge proofs \u6700\u8fd1\u3001 zero-knowledge proofs \\\uff08ZKPs\uff09\u3068\u547c\u3070\u308c\u308b\u4e00\u9023\u306e\u6697\u53f7\u30d7\u30ea\u30df\u30c6\u30a3\u30d6\u304c\u3001\u30d1\u30d6\u30ea\u30c3\u30af\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3084\u5206\u6563\u578b\u53f0\u5e33\u306e\u4e16\u754c\u3092\u64b9\u62cc\u3057\u3066\u3044\u308b\u3002ZKPs\u306f solution to privacy \u306e\u554f\u984c\u3068\u3057\u3066\u6700\u521d\u306b\u767b\u5834\u3057\u305f\u304c\u3001\u6700\u8fd1\u3067\u306f\u5b8c\u5168\u306a solution to scalability \u306e\u554f\u984c\u3068\u3057\u3066\u3082\u7acb\u3061\u4e0a\u304c\u3063\u3066\u3044\u308b\u3002\u305d\u306e\u7d50\u679c\u3001\u3053\u308c\u3089\u306e\u6697\u53f7\u8a3c\u660e\u306f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u30fb\u30b3\u30df\u30e5\u30cb\u30c6\u30a3\u306b\u3068\u3063\u3066\u975e\u5e38\u306b\u9b45\u529b\u7684\u306a\u30c4\u30fc\u30eb\u3068\u306a\u308a\u3001\u6700\u3082\u52b9\u7387\u7684\u306a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u3059\u3067\u306b\u3044\u304f\u3064\u304b\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u5c0e\u5165\u3055\u308c\u7d71\u5408\u3055\u308c\u3066\u3044\u307e\u3059\u3002 \u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u3068\u306f\u3001 prover \u3068\u547c\u3070\u308c\u308b\u4e00\u65b9\u306e\u5f53\u4e8b\u8005\u306b\u3001\u3042\u308b\u6587\u304c\u771f\u3067\u3042\u308b\u3053\u3068\u3092\u3001\u305d\u306e\u6587\u306e\u771f\u507d\u4ee5\u4e0a\u306e\u60c5\u5831\u3092\u660e\u304b\u3059\u3053\u3068\u306a\u304f\u3001 verifier \u3068\u547c\u3070\u308c\u308b\u4ed6\u65b9\u306e\u5f53\u4e8b\u8005\u306b\u7d0d\u5f97\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u30d7\u30ed\u30c8\u30b3\u30eb\u3067\u3042\u308b\u3002\u4f8b\u3048\u3070\u3001\u8a3c\u660e\u8005\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u6587\u306b\u5bfe\u3059\u308b\u8a3c\u660e\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \"I know the private key that corresponds to this public key\" : \u3053\u306e\u5834\u5408\u3001\u8a3c\u660e\u306f\u79d8\u5bc6\u9375\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u4e00\u5207\u660e\u3089\u304b\u306b\u3057\u306a\u3044\u3002 \"I know a private key that corresponds to a public key from this list\" : \u524d\u56de\u3068\u540c\u69d8\u306b\u3001\u8a3c\u660e\u306f\u79d8\u5bc6\u9375\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u660e\u3089\u304b\u306b\u3057\u306a\u3044\u304c\u3001\u3053\u306e\u5834\u5408\u3001\u95a2\u9023\u3059\u308b\u516c\u958b\u9375\u3082\u975e\u516c\u958b\u306e\u307e\u307e\u3067\u3042\u308b\u3002 \"I know the preimage of this hash value\" : \u3053\u306e\u5834\u5408\u3001\u8a3c\u660e\u306f\u8a3c\u660e\u8005\u304c\u524d\u50cf\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u793a\u3059\u304c\u3001\u305d\u306e\u524d\u50cf\u306e\u5024\u306b\u95a2\u3059\u308b\u60c5\u5831\u306f\u4e00\u5207\u660e\u304b\u3055\u306a\u3044\u3002 \"This is the hash of a blockchain block that does not produce negative balances\" : \u3053\u306e\u5834\u5408\u3001\u8a3c\u660e\u306f\u30d6\u30ed\u30c3\u30af\u306b\u542b\u307e\u308c\u308b\u53d6\u5f15\u306e\u91d1\u984d\u3001\u8d77\u6e90\u3001\u76ee\u7684\u5730\u306b\u95a2\u3059\u308b\u3044\u304b\u306a\u308b\u60c5\u5831\u3082\u660e\u3089\u304b\u306b\u3057\u306a\u3044\u3002 Non-interactive zero-knowledge proofs \\ (NIZK) \u306f\u3001\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306e\u7279\u6b8a\u306a\u30bf\u30a4\u30d7\u3067\u3001\u8a3c\u660e\u8005\u304c\u691c\u8a3c\u8005\u3068\u5bfe\u8a71\u305b\u305a\u306b\u8a3c\u660e\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002NIZK\u30d7\u30ed\u30c8\u30b3\u30eb\u306f\u3001 allow a smart contract to act as a verifier .Ethereum\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u975e\u5e38\u306b\u9069\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u65b9\u6cd5\u3067\u306f\u3001\u8ab0\u3067\u3082\u8a3c\u660e\u3092\u751f\u6210\u3057\u3001\u305d\u308c\u3092\u53d6\u5f15\u306e\u4e00\u90e8\u3068\u3057\u3066\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u9001\u4fe1\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u8a3c\u660e\u304c\u6709\u52b9\u304b\u3069\u3046\u304b\u306b\u5fdc\u3058\u3066\u4f55\u3089\u304b\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 \u305d\u306e\u4e2d\u3067\u3001\u6700\u3082\u597d\u307e\u3057\u3044NIZK\u306f\u3001 succinct proof size \u3068 sublinear verification time \u3092\u6301\u3064\u975e\u5bfe\u8a71\u7684\u30bc\u30ed\u77e5\u8b58\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u96c6\u5408\u3067\u3042\u308b zk-SNARK \u8a3c\u660e (Zero-knowledge Succinct Non Interactive ARgument of Knowledge\u3053\u308c\u3089\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u91cd\u8981\u6027\u306f2\u3064\u3042\u308a\u30011\u3064\u306f\u30d7\u30e9\u30a4\u30d0\u30b7\u30fc\u4fdd\u8a3c\u306e\u5411\u4e0a\u306b\u5f79\u7acb\u3064\u3053\u3068\u3001\u3082\u30461\u3064\u306f\u305d\u306e\u8a3c\u660e\u30b5\u30a4\u30ba\u306e\u5c0f\u3055\u3055\u304c\u30b9\u30b1\u30fc\u30e9\u30d3\u30ea\u30c6\u30a3\u306e\u89e3\u6c7a\u306b\u5229\u7528\u3055\u308c\u3066\u304d\u305f\u3053\u3068\u3067\u3059\u3002 Arithmetic circuits zk-SNARKs\u306f\u3001\u591a\u304f\u306eZKP\u3068\u540c\u69d8\u306b computational statements \u3092\u8a3c\u660e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304c\u3001\u8a08\u7b97\u554f\u984c\u306b\u76f4\u63a5\u9069\u7528\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u305a\u3001\u307e\u305a\u8a08\u7b97\u6587\u3092\u6b63\u3057\u3044\u5f62\u306b\u5909\u63db\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u5177\u4f53\u7684\u306b\u306f\u3001zk-SNARKs\u306f\u8a08\u7b97\u6587\u3092\u7b97\u8853\u56de\u8def\u3067\u30e2\u30c7\u30eb\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u306e\u5909\u63db\u306e\u65b9\u6cd5\u306f\u5fc5\u305a\u3057\u3082\u660e\u3089\u304b\u3067\u306f\u306a\u3044\u304c\u3001\u6211\u3005\u304c\u6ce8\u76ee\u3059\u308b\u307b\u3068\u3093\u3069\u306e\u8a08\u7b97\u554f\u984c\u306f\u3001\u5bb9\u6613\u306b\u7b97\u8853\u56de\u8def\u306b\u5909\u63db\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3042\u308b\u3002 F_p -arithmetic circuit \u306f\u3001\u30d5\u30a3\u30fc\u30eb\u30c9 F_p \u304b\u3089\u306e\u5024\u3092\u4f1d\u9001\u3057\u3001\u52a0\u7b97\u30fb\u4e57\u7b97\u30b2\u30fc\u30c8 modulo p \u306b\u63a5\u7d9a\u3059\u308b\u4e00\u9023\u306e\u914d\u7dda\u3067\u69cb\u6210\u3055\u308c\u308b\u56de\u8def\u3067\u3042\u308b\u3002 \ud83d\udc49 \u7d20\u6570 p \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001 finite field F_p \u306f\u3001 p \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u3053\u308c\u3089\u306e\u6570\u3092\u8db3\u3057\u305f\u308a\u304b\u3051\u305f\u308a\u3067\u304d\u308b\u6570 {0,...,p-1} \u306e\u96c6\u5408\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u601d\u3044\u51fa\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \u4f8b\u3048\u3070\u3001\u6709\u9650\u4f53 F_7 \u306f\u3001 {0,...,6} \u306e\u6570\u306e\u96c6\u5408\u304b\u3089\u306a\u308a\u3001 7 \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u52a0\u7b97\u30fb\u4e57\u7b97\u304c\u3067\u304d\u308b\u3002\u30e2\u30b8\u30e5\u30ed 7 \u306e\u6f14\u7b97\u3092\u7c21\u5358\u306b\u7406\u89e3\u3059\u308b\u306b\u306f\u3001\u6642\u8a08\u306e\u91dd\u304c\u4f55\u56de\u56de\u3063\u305f\u304b\u306f\u6c17\u306b\u305b\u305a\u3001\u4f55\u6642\u4f55\u5206\u306b\u91dd\u304c\u56de\u308b\u304b\u306e\u307f\u3092\u6c17\u306b\u3059\u308b think of a clock of 7 hours \u3092\u8003\u3048\u308c\u3070\u3088\u3044\u3002\u3064\u307e\u308a\u30017\u3067\u5272\u3063\u305f\u3068\u304d\u306e\u6ce8\u610f\u70b9\u3060\u3051\u3092\u6c17\u306b\u3059\u308b\u306e\u3067\u3042\u308b\u3002 15 modulo 7 = 1 \u3001 15 = 7 + 7 + 1 \u304b\u3089 7 modulo 7 = 0 4*3 modulo 7 = 5 \u3001 4*3 = 12 = 7 + 5 \u304b\u3089 Signals of a circuit \u305d\u3053\u3067\u3001\u6f14\u7b97\u56de\u8def\u306f 0,...,p-1 \u306e\u9593\u306e\u5024\u3067\u3042\u308b input signals \u3092\u3044\u304f\u3064\u304b\u53d6\u308a\u3001\u305d\u308c\u3089\u306e\u9593\u3067\u7d20\u6570 p \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u52a0\u7b97\u3068\u4e57\u7b97\u3092\u5b9f\u884c\u3059\u308b\u3002\u3059\u3079\u3066\u306e\u52a0\u7b97\u30fb\u4e57\u7b97\u30b2\u30fc\u30c8\u306e\u51fa\u529b\u306f\u3001\u56de\u8def\u306e\u6700\u5f8c\u306e\u30b2\u30fc\u30c8\u3092\u9664\u3044\u3066\u3001 intermediate signal \u3068\u307f\u306a\u3055\u308c\u3001\u305d\u306e\u51fa\u529b , \u304c\u56de\u8def\u306e output signal \u3068\u306a\u308b\u3002 Ethereum \u3067zk-SNARK\u8a3c\u660e\u3092\u751f\u6210\u30fb\u691c\u8a3c\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u7d20\u6570\u3092\u3068\u3063\u3066 F_p \u306e\u7b97\u8853\u56de\u8def\u3092\u6271\u3046\u5fc5\u8981\u304c\u3042\u308b\u3002 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617 \u4e0b\u56f3\u3067\u306f\u3001\u6f14\u7b97\u3092\u884c\u3046 F_7 -\u7b97\u8853\u56de\u8def\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002 out = a*b + c .\u3053\u306e\u56de\u8def\u306f5\u3064\u306e\u4fe1\u53f7\u3092\u6301\u3061\u3001\u4fe1\u53f7 a \u3001 b \u3001 c \u306f\u5165\u529b\u4fe1\u53f7\u3001 d \u306f\u4e2d\u9593\u4fe1\u53f7\u3001 out \u306f\u56de\u8def\u306e\u51fa\u529b\u3067\u3042\u308b\u3002 \u200b zk-SNARK\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u4f7f\u3046\u306b\u306f\u3001\u4fe1\u53f7\u9593\u306e\u95a2\u4fc2\u3092\u5909\u6570\u3068\u30b2\u30fc\u30c8\u3092\u95a2\u4fc2\u3065\u3051\u308b\u65b9\u7a0b\u5f0f\u7cfb\u3068\u3057\u3066\u8a18\u8ff0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u308c\u4ee5\u964d\u3001\u56de\u8def\u3092\u8a18\u8ff0\u3059\u308b\u65b9\u7a0b\u5f0f\u3092 constraints \u3068\u547c\u3073\u3001\u305d\u306e\u56de\u8def\u306e\u4fe1\u53f7\u304c\u6e80\u305f\u3059\u3079\u304d\u6761\u4ef6\u3068\u8003\u3048\u308c\u3070\u3088\u3044\u3002 Rank-1 constraint system \u4fe1\u53f7 s_1,...,s_n \u3092\u6301\u3064\u6f14\u7b97\u56de\u8def\u304c\u3042\u308b\u3068\u3059\u308c\u3070\u3001 constraint \u3092\u6b21\u306e\u3088\u3046\u306a\u5f62\u306e\u65b9\u7a0b\u5f0f\u3067\u5b9a\u7fa9\u3059\u308b\u3002 (a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0 \u306a\u304a\u3001\u5236\u7d04 must be quadratic, linear or constant equations \u306f\u3001\u5c0f\u3055\u306a\u4fee\u6b63(\u5909\u6570\u306e\u5909\u66f4\u30842\u3064\u306e\u5236\u7d04\u3092\u96c6\u3081\u308b\u306a\u3069)\u3092\u884c\u3046\u3053\u3068\u3067\u3001\u5236\u7d04\u3084\u5909\u6570\u306e\u6570\u3092\u6e1b\u3089\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059\u3002\u4e00\u822c\u306b\u3001\u56de\u8def\u306b\u306f\u8907\u6570\u306e\u5236\u7d04\u6761\u4ef6(\u901a\u5e38\u3001\u4e57\u6cd5\u30b2\u30fc\u30c8\u3054\u3068\u306b1\u3064)\u304c\u3042\u308a\u307e\u3059\u3002\u56de\u8def\u3092\u8a18\u8ff0\u3059\u308b\u5236\u7d04\u306e\u96c6\u5408\u3092 rank-1 constraint system (R1CS)\u3068\u547c\u3073\u307e\u3059\u3002 (a_11*s_1 + ... + a_1n*s_n)*(b_11*s_1 + ... + b_1n*s_n) + (c_11*s_1 + ... + c_1n*s_n) = 0 (a_21*s_1 + ... + a_2n*s_n)*(b_21*s_1 + ... + b_2n*s_n) + (c_21*s_1 + ... + c_1n*s_n) = 0 (a_31*s_1 + ... + a_3n*s_n)*(b_31*s_1 + ... + b_3n*s_n) + (c_31*s_1 + ... + c_1n*s_n) = 0 ... ... (a_m1*s_1 + ... + a_mn*s_n)*(b_m1*s_1 + ... + b_mn*s_n) + (c_m1*s_1 + ... + c_mn*s_n) = 0 \u56de\u8def\u5185\u306e\u6f14\u7b97\u306f\u3042\u308b\u7d20\u6570 p \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u884c\u308f\u308c\u308b\u3053\u3068\u3092\u899a\u3048\u3066\u304a\u3044\u3066\u307b\u3057\u3044\u3002\u3064\u307e\u308a\u3001\u4e0a\u306e\u5f0f\u306f\u3059\u3079\u3066 modulo p \u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3002 \u5148\u306e\u4f8b\u3067\u306f\u3001\u3053\u306e\u56de\u8def\u306eR1CS\u306f\u6b21\u306e2\u3064\u306e\u5f0f\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\u3002 d = a*b modulo 7 out = d+c modulo 7 \u3053\u306e\u5834\u5408\u3001\u5909\u6570 d \u3092\u76f4\u63a5\u7f6e\u304d\u63db\u3048\u308b\u3053\u3068\u3067\u30012\u3064\u306e\u65b9\u7a0b\u5f0f\u30921\u3064\u306b\u307e\u3068\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 out = a*b + c modulo 7 \u56de\u8def\u306b\u3064\u3044\u3066\u306e\u826f\u3044\u3068\u3053\u308d\u306f\u3001\u591a\u304f\u306e\u958b\u767a\u8005\u306b\u3068\u3063\u3066\u5727\u5012\u7684\u3067\u3042\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u307b\u3068\u3093\u3069\u306e zero-knowledge protocols have an inherent complexity \u304c\u3001 design of arithmetic circuits is clear and neat \u3067\u3042\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u3002 \ud83d\udc49 circom \u3067\u306f\u3001\u81ea\u5206\u3067\u56de\u8def\u3092\u8a2d\u8a08\u3057\u3001\u81ea\u5206\u3067\u5236\u7d04\u3092\u8a2d\u5b9a\u3057\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306b\u5fc5\u8981\u306aR1CS\u8868\u73fe\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 \u30bc\u30ed\u77e5\u8b58\u306f\u3001 circuit satisfiability \u3092\u8a3c\u660e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u3053\u308c\u306f\u3069\u3046\u3044\u3046\u3053\u3068\u304b\u3068\u3044\u3046\u3068\u3001\u56de\u8def\u3092\u6e80\u305f\u3059\u4fe1\u53f7\u306e\u96c6\u5408\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3001\u8a00\u3044\u63db\u3048\u308c\u3070\u3001R1CS\u306e\u89e3\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u8a3c\u660e\u3067\u304d\u308b\u306e\u3067\u3059\u3002\u3053\u306e\u4fe1\u53f7\u306e\u96c6\u5408\u3092 witness \u3068\u547c\u3076\u3002 Witness \u5165\u529b\u306e\u30bb\u30c3\u30c8\u304c\u3042\u308c\u3070\u3001\u4e2d\u9593\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u306e\u8a08\u7b97\u306f\u975e\u5e38\u306b\u7c21\u5358\u3067\u3042\u308b\u3002\u3064\u307e\u308a\u3001\u4efb\u610f\u306e\u5165\u529b\u306e\u96c6\u5408\u304c\u3042\u308c\u3070\u3001\u6b8b\u308a\u306e\u4fe1\u53f7\u306f\u5fc5\u305a\u8a08\u7b97\u3067\u304d\u308b\u3002\u3067\u306f\u3001\u306a\u305c\u56de\u8def\u5145\u8db3\u6027\u306e\u8a71\u3092\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3057\u3087\u3046\u304b\uff1f\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306e\u91cd\u8981\u306a\u70b9\u306f\u3001\u4fe1\u53f7\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u660e\u3089\u304b\u306b\u3059\u308b\u3053\u3068\u306a\u304f\u3001\u3053\u308c\u3089\u306e\u56de\u8def\u3092\u8a08\u7b97\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3053\u3068\u3067\u3059\u3002 \u4f8b\u3048\u3070\u3001\u5148\u306e\u56de\u8def\u3067\u5165\u529b a \u304c\u79d8\u5bc6\u9375\u3001\u5165\u529b b \u304c\u305d\u308c\u306b\u5bfe\u5fdc\u3059\u308b\u516c\u958b\u9375\u3067\u3042\u3063\u305f\u3068\u3059\u308b\u3002 b \u306f\u516c\u958b\u3057\u3066\u3082\u69cb\u308f\u306a\u3044\u304c\u3001 a \u306f\u7d76\u5bfe\u306b\u516c\u958b\u3057\u305f\u304f\u306a\u3044\u3068\u601d\u3046\u3060\u308d\u3046\u3002 a \u3092\u79d8\u5bc6\u5165\u529b\u3001 b \u3001 c \u3092\u516c\u958b\u5165\u529b\u3001 out \u3092\u516c\u958b\u51fa\u529b\u3068\u5b9a\u7fa9\u3059\u308b\u3068\u3001\u3042\u308b\u516c\u958b\u5024 b \u3001 c \u3001 out \u306b\u5bfe\u3057\u3066\u3001\u5f0f a*b + c = out mod 7 \u304c\u6210\u308a\u7acb\u3064\u3088\u3046\u306a\u79d8\u5bc6\u5165\u529b a \u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u3001\u30bc\u30ed\u77e5\u8b58\u3067\u305d\u306e\u5024\u3092\u660e\u304b\u3059\u3053\u3068\u306a\u304f\u8a3c\u660e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 a \u306e\u5024\u3092\u4ed6\u306e\u4fe1\u53f7\u304b\u3089\u5206\u96e2\u3059\u308c\u3070\u3001\u5bb9\u6613\u306b\u63a8\u8ad6\u3067\u304d\u308b\u3053\u3068\u306b\u6ce8\u610f\u3002\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u5165\u529b\u306e\u30d7\u30e9\u30a4\u30d0\u30b7\u30fc\u3092\u5b88\u308a\u3001R1CS\u304b\u3089\u63a8\u8ad6\u3055\u308c\u306a\u3044\u3088\u3046\u306b\u56de\u8def\u8a2d\u8a08\u3059\u308b\u3053\u3068\u304c\u91cd\u8981\u3067\u3042\u308b\u3002 \u4fe1\u53f7\u306e\u5272\u308a\u5f53\u3066\u3092 witness \u3068\u547c\u3076\u3002\u4f8b\u3048\u3070\u3001 {a = 2, b = 6, c = -1, out = 4} \u306f\u3053\u306e\u56de\u8def\u306e\u6709\u52b9\u306a\u8a3c\u4eba\u3068\u306a\u308b\u3002 {a = 1, b = 2, c = 1, out = 0} \u306f a*b - c = out \u306e\u5f0f\u3092\u6e80\u305f\u3055\u306a\u3044\u306e\u3067\u3001\u6709\u52b9\u306a\u8a3c\u4eba\u3068\u306f\u306a\u3089\u306a\u3044\u3002 Summary In summary, zk-SNARK proofs are an specific type of zero-knowledge proofs that allow you to prove that you know a set of signals \\(witness\\) that match all the constraints of a circuit without revealing any of the signals except the public inputs and the outputs.","title":"\u30bc\u30ed\u77e5\u8b58\u306e\u80cc\u666f"},{"location":"background/background/#background","text":"","title":"Background"},{"location":"background/background/#zero-knowledge-proofs","text":"\u6700\u8fd1\u3001 zero-knowledge proofs \\\uff08ZKPs\uff09\u3068\u547c\u3070\u308c\u308b\u4e00\u9023\u306e\u6697\u53f7\u30d7\u30ea\u30df\u30c6\u30a3\u30d6\u304c\u3001\u30d1\u30d6\u30ea\u30c3\u30af\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3084\u5206\u6563\u578b\u53f0\u5e33\u306e\u4e16\u754c\u3092\u64b9\u62cc\u3057\u3066\u3044\u308b\u3002ZKPs\u306f solution to privacy \u306e\u554f\u984c\u3068\u3057\u3066\u6700\u521d\u306b\u767b\u5834\u3057\u305f\u304c\u3001\u6700\u8fd1\u3067\u306f\u5b8c\u5168\u306a solution to scalability \u306e\u554f\u984c\u3068\u3057\u3066\u3082\u7acb\u3061\u4e0a\u304c\u3063\u3066\u3044\u308b\u3002\u305d\u306e\u7d50\u679c\u3001\u3053\u308c\u3089\u306e\u6697\u53f7\u8a3c\u660e\u306f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u30fb\u30b3\u30df\u30e5\u30cb\u30c6\u30a3\u306b\u3068\u3063\u3066\u975e\u5e38\u306b\u9b45\u529b\u7684\u306a\u30c4\u30fc\u30eb\u3068\u306a\u308a\u3001\u6700\u3082\u52b9\u7387\u7684\u306a\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u3059\u3067\u306b\u3044\u304f\u3064\u304b\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u5c0e\u5165\u3055\u308c\u7d71\u5408\u3055\u308c\u3066\u3044\u307e\u3059\u3002 \u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u3068\u306f\u3001 prover \u3068\u547c\u3070\u308c\u308b\u4e00\u65b9\u306e\u5f53\u4e8b\u8005\u306b\u3001\u3042\u308b\u6587\u304c\u771f\u3067\u3042\u308b\u3053\u3068\u3092\u3001\u305d\u306e\u6587\u306e\u771f\u507d\u4ee5\u4e0a\u306e\u60c5\u5831\u3092\u660e\u304b\u3059\u3053\u3068\u306a\u304f\u3001 verifier \u3068\u547c\u3070\u308c\u308b\u4ed6\u65b9\u306e\u5f53\u4e8b\u8005\u306b\u7d0d\u5f97\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u30d7\u30ed\u30c8\u30b3\u30eb\u3067\u3042\u308b\u3002\u4f8b\u3048\u3070\u3001\u8a3c\u660e\u8005\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u6587\u306b\u5bfe\u3059\u308b\u8a3c\u660e\u3092\u4f5c\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \"I know the private key that corresponds to this public key\" : \u3053\u306e\u5834\u5408\u3001\u8a3c\u660e\u306f\u79d8\u5bc6\u9375\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u4e00\u5207\u660e\u3089\u304b\u306b\u3057\u306a\u3044\u3002 \"I know a private key that corresponds to a public key from this list\" : \u524d\u56de\u3068\u540c\u69d8\u306b\u3001\u8a3c\u660e\u306f\u79d8\u5bc6\u9375\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u660e\u3089\u304b\u306b\u3057\u306a\u3044\u304c\u3001\u3053\u306e\u5834\u5408\u3001\u95a2\u9023\u3059\u308b\u516c\u958b\u9375\u3082\u975e\u516c\u958b\u306e\u307e\u307e\u3067\u3042\u308b\u3002 \"I know the preimage of this hash value\" : \u3053\u306e\u5834\u5408\u3001\u8a3c\u660e\u306f\u8a3c\u660e\u8005\u304c\u524d\u50cf\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u793a\u3059\u304c\u3001\u305d\u306e\u524d\u50cf\u306e\u5024\u306b\u95a2\u3059\u308b\u60c5\u5831\u306f\u4e00\u5207\u660e\u304b\u3055\u306a\u3044\u3002 \"This is the hash of a blockchain block that does not produce negative balances\" : \u3053\u306e\u5834\u5408\u3001\u8a3c\u660e\u306f\u30d6\u30ed\u30c3\u30af\u306b\u542b\u307e\u308c\u308b\u53d6\u5f15\u306e\u91d1\u984d\u3001\u8d77\u6e90\u3001\u76ee\u7684\u5730\u306b\u95a2\u3059\u308b\u3044\u304b\u306a\u308b\u60c5\u5831\u3082\u660e\u3089\u304b\u306b\u3057\u306a\u3044\u3002 Non-interactive zero-knowledge proofs \\ (NIZK) \u306f\u3001\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306e\u7279\u6b8a\u306a\u30bf\u30a4\u30d7\u3067\u3001\u8a3c\u660e\u8005\u304c\u691c\u8a3c\u8005\u3068\u5bfe\u8a71\u305b\u305a\u306b\u8a3c\u660e\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002NIZK\u30d7\u30ed\u30c8\u30b3\u30eb\u306f\u3001 allow a smart contract to act as a verifier .Ethereum\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u975e\u5e38\u306b\u9069\u3057\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u65b9\u6cd5\u3067\u306f\u3001\u8ab0\u3067\u3082\u8a3c\u660e\u3092\u751f\u6210\u3057\u3001\u305d\u308c\u3092\u53d6\u5f15\u306e\u4e00\u90e8\u3068\u3057\u3066\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u9001\u4fe1\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u8a3c\u660e\u304c\u6709\u52b9\u304b\u3069\u3046\u304b\u306b\u5fdc\u3058\u3066\u4f55\u3089\u304b\u306e\u30a2\u30af\u30b7\u30e7\u30f3\u3092\u5b9f\u884c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 \u305d\u306e\u4e2d\u3067\u3001\u6700\u3082\u597d\u307e\u3057\u3044NIZK\u306f\u3001 succinct proof size \u3068 sublinear verification time \u3092\u6301\u3064\u975e\u5bfe\u8a71\u7684\u30bc\u30ed\u77e5\u8b58\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u96c6\u5408\u3067\u3042\u308b zk-SNARK \u8a3c\u660e (Zero-knowledge Succinct Non Interactive ARgument of Knowledge\u3053\u308c\u3089\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\u306e\u91cd\u8981\u6027\u306f2\u3064\u3042\u308a\u30011\u3064\u306f\u30d7\u30e9\u30a4\u30d0\u30b7\u30fc\u4fdd\u8a3c\u306e\u5411\u4e0a\u306b\u5f79\u7acb\u3064\u3053\u3068\u3001\u3082\u30461\u3064\u306f\u305d\u306e\u8a3c\u660e\u30b5\u30a4\u30ba\u306e\u5c0f\u3055\u3055\u304c\u30b9\u30b1\u30fc\u30e9\u30d3\u30ea\u30c6\u30a3\u306e\u89e3\u6c7a\u306b\u5229\u7528\u3055\u308c\u3066\u304d\u305f\u3053\u3068\u3067\u3059\u3002","title":"Zero-knowledge proofs "},{"location":"background/background/#arithmetic-circuits","text":"zk-SNARKs\u306f\u3001\u591a\u304f\u306eZKP\u3068\u540c\u69d8\u306b computational statements \u3092\u8a3c\u660e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304c\u3001\u8a08\u7b97\u554f\u984c\u306b\u76f4\u63a5\u9069\u7528\u3059\u308b\u3053\u3068\u306f\u3067\u304d\u305a\u3001\u307e\u305a\u8a08\u7b97\u6587\u3092\u6b63\u3057\u3044\u5f62\u306b\u5909\u63db\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u5177\u4f53\u7684\u306b\u306f\u3001zk-SNARKs\u306f\u8a08\u7b97\u6587\u3092\u7b97\u8853\u56de\u8def\u3067\u30e2\u30c7\u30eb\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u306e\u5909\u63db\u306e\u65b9\u6cd5\u306f\u5fc5\u305a\u3057\u3082\u660e\u3089\u304b\u3067\u306f\u306a\u3044\u304c\u3001\u6211\u3005\u304c\u6ce8\u76ee\u3059\u308b\u307b\u3068\u3093\u3069\u306e\u8a08\u7b97\u554f\u984c\u306f\u3001\u5bb9\u6613\u306b\u7b97\u8853\u56de\u8def\u306b\u5909\u63db\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\u3067\u3042\u308b\u3002 F_p -arithmetic circuit \u306f\u3001\u30d5\u30a3\u30fc\u30eb\u30c9 F_p \u304b\u3089\u306e\u5024\u3092\u4f1d\u9001\u3057\u3001\u52a0\u7b97\u30fb\u4e57\u7b97\u30b2\u30fc\u30c8 modulo p \u306b\u63a5\u7d9a\u3059\u308b\u4e00\u9023\u306e\u914d\u7dda\u3067\u69cb\u6210\u3055\u308c\u308b\u56de\u8def\u3067\u3042\u308b\u3002 \ud83d\udc49 \u7d20\u6570 p \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001 finite field F_p \u306f\u3001 p \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u3053\u308c\u3089\u306e\u6570\u3092\u8db3\u3057\u305f\u308a\u304b\u3051\u305f\u308a\u3067\u304d\u308b\u6570 {0,...,p-1} \u306e\u96c6\u5408\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u601d\u3044\u51fa\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \u4f8b\u3048\u3070\u3001\u6709\u9650\u4f53 F_7 \u306f\u3001 {0,...,6} \u306e\u6570\u306e\u96c6\u5408\u304b\u3089\u306a\u308a\u3001 7 \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u52a0\u7b97\u30fb\u4e57\u7b97\u304c\u3067\u304d\u308b\u3002\u30e2\u30b8\u30e5\u30ed 7 \u306e\u6f14\u7b97\u3092\u7c21\u5358\u306b\u7406\u89e3\u3059\u308b\u306b\u306f\u3001\u6642\u8a08\u306e\u91dd\u304c\u4f55\u56de\u56de\u3063\u305f\u304b\u306f\u6c17\u306b\u305b\u305a\u3001\u4f55\u6642\u4f55\u5206\u306b\u91dd\u304c\u56de\u308b\u304b\u306e\u307f\u3092\u6c17\u306b\u3059\u308b think of a clock of 7 hours \u3092\u8003\u3048\u308c\u3070\u3088\u3044\u3002\u3064\u307e\u308a\u30017\u3067\u5272\u3063\u305f\u3068\u304d\u306e\u6ce8\u610f\u70b9\u3060\u3051\u3092\u6c17\u306b\u3059\u308b\u306e\u3067\u3042\u308b\u3002 15 modulo 7 = 1 \u3001 15 = 7 + 7 + 1 \u304b\u3089 7 modulo 7 = 0 4*3 modulo 7 = 5 \u3001 4*3 = 12 = 7 + 5 \u304b\u3089","title":"Arithmetic circuits "},{"location":"background/background/#signals-of-a-circuit","text":"\u305d\u3053\u3067\u3001\u6f14\u7b97\u56de\u8def\u306f 0,...,p-1 \u306e\u9593\u306e\u5024\u3067\u3042\u308b input signals \u3092\u3044\u304f\u3064\u304b\u53d6\u308a\u3001\u305d\u308c\u3089\u306e\u9593\u3067\u7d20\u6570 p \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u52a0\u7b97\u3068\u4e57\u7b97\u3092\u5b9f\u884c\u3059\u308b\u3002\u3059\u3079\u3066\u306e\u52a0\u7b97\u30fb\u4e57\u7b97\u30b2\u30fc\u30c8\u306e\u51fa\u529b\u306f\u3001\u56de\u8def\u306e\u6700\u5f8c\u306e\u30b2\u30fc\u30c8\u3092\u9664\u3044\u3066\u3001 intermediate signal \u3068\u307f\u306a\u3055\u308c\u3001\u305d\u306e\u51fa\u529b , \u304c\u56de\u8def\u306e output signal \u3068\u306a\u308b\u3002 Ethereum \u3067zk-SNARK\u8a3c\u660e\u3092\u751f\u6210\u30fb\u691c\u8a3c\u3059\u308b\u305f\u3081\u306b\u306f\u3001\u7d20\u6570\u3092\u3068\u3063\u3066 F_p \u306e\u7b97\u8853\u56de\u8def\u3092\u6271\u3046\u5fc5\u8981\u304c\u3042\u308b\u3002 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617 \u4e0b\u56f3\u3067\u306f\u3001\u6f14\u7b97\u3092\u884c\u3046 F_7 -\u7b97\u8853\u56de\u8def\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\u3002 out = a*b + c .\u3053\u306e\u56de\u8def\u306f5\u3064\u306e\u4fe1\u53f7\u3092\u6301\u3061\u3001\u4fe1\u53f7 a \u3001 b \u3001 c \u306f\u5165\u529b\u4fe1\u53f7\u3001 d \u306f\u4e2d\u9593\u4fe1\u53f7\u3001 out \u306f\u56de\u8def\u306e\u51fa\u529b\u3067\u3042\u308b\u3002","title":"Signals of a circuit "},{"location":"background/background/#_1","text":"zk-SNARK\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u4f7f\u3046\u306b\u306f\u3001\u4fe1\u53f7\u9593\u306e\u95a2\u4fc2\u3092\u5909\u6570\u3068\u30b2\u30fc\u30c8\u3092\u95a2\u4fc2\u3065\u3051\u308b\u65b9\u7a0b\u5f0f\u7cfb\u3068\u3057\u3066\u8a18\u8ff0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u3053\u308c\u4ee5\u964d\u3001\u56de\u8def\u3092\u8a18\u8ff0\u3059\u308b\u65b9\u7a0b\u5f0f\u3092 constraints \u3068\u547c\u3073\u3001\u305d\u306e\u56de\u8def\u306e\u4fe1\u53f7\u304c\u6e80\u305f\u3059\u3079\u304d\u6761\u4ef6\u3068\u8003\u3048\u308c\u3070\u3088\u3044\u3002","title":"\u200b "},{"location":"background/background/#rank-1-constraint-system","text":"\u4fe1\u53f7 s_1,...,s_n \u3092\u6301\u3064\u6f14\u7b97\u56de\u8def\u304c\u3042\u308b\u3068\u3059\u308c\u3070\u3001 constraint \u3092\u6b21\u306e\u3088\u3046\u306a\u5f62\u306e\u65b9\u7a0b\u5f0f\u3067\u5b9a\u7fa9\u3059\u308b\u3002 (a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0 \u306a\u304a\u3001\u5236\u7d04 must be quadratic, linear or constant equations \u306f\u3001\u5c0f\u3055\u306a\u4fee\u6b63(\u5909\u6570\u306e\u5909\u66f4\u30842\u3064\u306e\u5236\u7d04\u3092\u96c6\u3081\u308b\u306a\u3069)\u3092\u884c\u3046\u3053\u3068\u3067\u3001\u5236\u7d04\u3084\u5909\u6570\u306e\u6570\u3092\u6e1b\u3089\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059\u3002\u4e00\u822c\u306b\u3001\u56de\u8def\u306b\u306f\u8907\u6570\u306e\u5236\u7d04\u6761\u4ef6(\u901a\u5e38\u3001\u4e57\u6cd5\u30b2\u30fc\u30c8\u3054\u3068\u306b1\u3064)\u304c\u3042\u308a\u307e\u3059\u3002\u56de\u8def\u3092\u8a18\u8ff0\u3059\u308b\u5236\u7d04\u306e\u96c6\u5408\u3092 rank-1 constraint system (R1CS)\u3068\u547c\u3073\u307e\u3059\u3002 (a_11*s_1 + ... + a_1n*s_n)*(b_11*s_1 + ... + b_1n*s_n) + (c_11*s_1 + ... + c_1n*s_n) = 0 (a_21*s_1 + ... + a_2n*s_n)*(b_21*s_1 + ... + b_2n*s_n) + (c_21*s_1 + ... + c_1n*s_n) = 0 (a_31*s_1 + ... + a_3n*s_n)*(b_31*s_1 + ... + b_3n*s_n) + (c_31*s_1 + ... + c_1n*s_n) = 0 ... ... (a_m1*s_1 + ... + a_mn*s_n)*(b_m1*s_1 + ... + b_mn*s_n) + (c_m1*s_1 + ... + c_mn*s_n) = 0 \u56de\u8def\u5185\u306e\u6f14\u7b97\u306f\u3042\u308b\u7d20\u6570 p \u306e\u30e2\u30b8\u30e5\u30ed\u3067\u884c\u308f\u308c\u308b\u3053\u3068\u3092\u899a\u3048\u3066\u304a\u3044\u3066\u307b\u3057\u3044\u3002\u3064\u307e\u308a\u3001\u4e0a\u306e\u5f0f\u306f\u3059\u3079\u3066 modulo p \u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3002 \u5148\u306e\u4f8b\u3067\u306f\u3001\u3053\u306e\u56de\u8def\u306eR1CS\u306f\u6b21\u306e2\u3064\u306e\u5f0f\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\u3002 d = a*b modulo 7 out = d+c modulo 7 \u3053\u306e\u5834\u5408\u3001\u5909\u6570 d \u3092\u76f4\u63a5\u7f6e\u304d\u63db\u3048\u308b\u3053\u3068\u3067\u30012\u3064\u306e\u65b9\u7a0b\u5f0f\u30921\u3064\u306b\u307e\u3068\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 out = a*b + c modulo 7 \u56de\u8def\u306b\u3064\u3044\u3066\u306e\u826f\u3044\u3068\u3053\u308d\u306f\u3001\u591a\u304f\u306e\u958b\u767a\u8005\u306b\u3068\u3063\u3066\u5727\u5012\u7684\u3067\u3042\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u307b\u3068\u3093\u3069\u306e zero-knowledge protocols have an inherent complexity \u304c\u3001 design of arithmetic circuits is clear and neat \u3067\u3042\u308b\u3068\u3044\u3046\u3053\u3068\u3067\u3059\u3002 \ud83d\udc49 circom \u3067\u306f\u3001\u81ea\u5206\u3067\u56de\u8def\u3092\u8a2d\u8a08\u3057\u3001\u81ea\u5206\u3067\u5236\u7d04\u3092\u8a2d\u5b9a\u3057\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306b\u5fc5\u8981\u306aR1CS\u8868\u73fe\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 \u30bc\u30ed\u77e5\u8b58\u306f\u3001 circuit satisfiability \u3092\u8a3c\u660e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u3053\u308c\u306f\u3069\u3046\u3044\u3046\u3053\u3068\u304b\u3068\u3044\u3046\u3068\u3001\u56de\u8def\u3092\u6e80\u305f\u3059\u4fe1\u53f7\u306e\u96c6\u5408\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3001\u8a00\u3044\u63db\u3048\u308c\u3070\u3001R1CS\u306e\u89e3\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u8a3c\u660e\u3067\u304d\u308b\u306e\u3067\u3059\u3002\u3053\u306e\u4fe1\u53f7\u306e\u96c6\u5408\u3092 witness \u3068\u547c\u3076\u3002","title":"Rank-1 constraint system "},{"location":"background/background/#witness","text":"\u5165\u529b\u306e\u30bb\u30c3\u30c8\u304c\u3042\u308c\u3070\u3001\u4e2d\u9593\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u306e\u8a08\u7b97\u306f\u975e\u5e38\u306b\u7c21\u5358\u3067\u3042\u308b\u3002\u3064\u307e\u308a\u3001\u4efb\u610f\u306e\u5165\u529b\u306e\u96c6\u5408\u304c\u3042\u308c\u3070\u3001\u6b8b\u308a\u306e\u4fe1\u53f7\u306f\u5fc5\u305a\u8a08\u7b97\u3067\u304d\u308b\u3002\u3067\u306f\u3001\u306a\u305c\u56de\u8def\u5145\u8db3\u6027\u306e\u8a71\u3092\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3057\u3087\u3046\u304b\uff1f\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u306e\u91cd\u8981\u306a\u70b9\u306f\u3001\u4fe1\u53f7\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u660e\u3089\u304b\u306b\u3059\u308b\u3053\u3068\u306a\u304f\u3001\u3053\u308c\u3089\u306e\u56de\u8def\u3092\u8a08\u7b97\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3053\u3068\u3067\u3059\u3002 \u4f8b\u3048\u3070\u3001\u5148\u306e\u56de\u8def\u3067\u5165\u529b a \u304c\u79d8\u5bc6\u9375\u3001\u5165\u529b b \u304c\u305d\u308c\u306b\u5bfe\u5fdc\u3059\u308b\u516c\u958b\u9375\u3067\u3042\u3063\u305f\u3068\u3059\u308b\u3002 b \u306f\u516c\u958b\u3057\u3066\u3082\u69cb\u308f\u306a\u3044\u304c\u3001 a \u306f\u7d76\u5bfe\u306b\u516c\u958b\u3057\u305f\u304f\u306a\u3044\u3068\u601d\u3046\u3060\u308d\u3046\u3002 a \u3092\u79d8\u5bc6\u5165\u529b\u3001 b \u3001 c \u3092\u516c\u958b\u5165\u529b\u3001 out \u3092\u516c\u958b\u51fa\u529b\u3068\u5b9a\u7fa9\u3059\u308b\u3068\u3001\u3042\u308b\u516c\u958b\u5024 b \u3001 c \u3001 out \u306b\u5bfe\u3057\u3066\u3001\u5f0f a*b + c = out mod 7 \u304c\u6210\u308a\u7acb\u3064\u3088\u3046\u306a\u79d8\u5bc6\u5165\u529b a \u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u3001\u30bc\u30ed\u77e5\u8b58\u3067\u305d\u306e\u5024\u3092\u660e\u304b\u3059\u3053\u3068\u306a\u304f\u8a3c\u660e\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 a \u306e\u5024\u3092\u4ed6\u306e\u4fe1\u53f7\u304b\u3089\u5206\u96e2\u3059\u308c\u3070\u3001\u5bb9\u6613\u306b\u63a8\u8ad6\u3067\u304d\u308b\u3053\u3068\u306b\u6ce8\u610f\u3002\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u5165\u529b\u306e\u30d7\u30e9\u30a4\u30d0\u30b7\u30fc\u3092\u5b88\u308a\u3001R1CS\u304b\u3089\u63a8\u8ad6\u3055\u308c\u306a\u3044\u3088\u3046\u306b\u56de\u8def\u8a2d\u8a08\u3059\u308b\u3053\u3068\u304c\u91cd\u8981\u3067\u3042\u308b\u3002 \u4fe1\u53f7\u306e\u5272\u308a\u5f53\u3066\u3092 witness \u3068\u547c\u3076\u3002\u4f8b\u3048\u3070\u3001 {a = 2, b = 6, c = -1, out = 4} \u306f\u3053\u306e\u56de\u8def\u306e\u6709\u52b9\u306a\u8a3c\u4eba\u3068\u306a\u308b\u3002 {a = 1, b = 2, c = 1, out = 0} \u306f a*b - c = out \u306e\u5f0f\u3092\u6e80\u305f\u3055\u306a\u3044\u306e\u3067\u3001\u6709\u52b9\u306a\u8a3c\u4eba\u3068\u306f\u306a\u3089\u306a\u3044\u3002","title":"Witness "},{"location":"background/background/#summary","text":"In summary, zk-SNARK proofs are an specific type of zero-knowledge proofs that allow you to prove that you know a set of signals \\(witness\\) that match all the constraints of a circuit without revealing any of the signals except the public inputs and the outputs.","title":"Summary "},{"location":"circom-language/anonymous-components-and-tuples/","text":"Tuples and Anonymous Components Anonymous Components circom 2.1.0 introduces a new feature called anonymous component . An anonymous component allows in a single instruction 1) the implicit declaration of a new component, 2) the assignment of every input signal and, finally, 3) the assignment of every output signal. This section is divided in the next subsections: 1. Syntax and semantics of anonymous components . 2. What if the anonymous component is an instance of a template with more than an output signal? We introduce the tuples in circom. 3. What if the anonymous component is an instance of a template which input/output signals are arrays? We introduce the element-wise assignment for signal arrays. 4. What if we are not interested in collecting one of the outputs? We introduce the use of \"_\" to indicate that a signal is not relevant. Syntax and semantics of anonymous components Let us see a typical circom program. template A(n){ signal input a, b; signal output c; c <== a*b; } template B(n){ signal input in[n]; signal out; component temp_a = A(n); temp_a.a <== in[0]; temp_a.b <== in[1]; out <== temp_a.c; } component main = B(2); Thanks to the use of anonymous components, we can easily write the next program, which is, equivalent to the previous one, but its code is much cleaner. template A(n){ signal input a, b; signal output c; c <== a*b; } template B(n){ signal input in[n]; signal out <== A(n)(in[0],in[1]); } component main = B(2); It is important to highlight that both circuits are equivalent: they have the same witnesses and the same constraint, that is, out === in[0]*in[1] . The anonymous components are a new kind of circom expression whose syntax is as follows: temp_name(arg1,...,argN)(input1,...,inputM) assuming that we have a template temp_name with N arguments and M input signals. Let us clarify two points: 1. arg1 , ..., argN are template arguments. We can use them as usual. They can be arithmetic operations expressions or constants. The important thing is its value must be known at compilation time. 2. input1 , ..., inputM are input signals. We can pass another signals, (just like in the example) constants or other anonymous components (in a compositional way), if and only if, such components only have 1 output signal . The order of the signals in the anonymous component matters: the ith input signal receives the value of the ith signal passed as parameter. Since circom 2.1.1, it is also allowed to indicate the name of the input signal corresponding to each parameter, followed by <== or <-- and, finally, the signal which gives the value). The only condition that must be satisfied is that all the subcomponent inputs must receive a value. Let us see this new feature in the previous example: template A(n){ signal input a, b; signal output c; c <== a*b; } template B(n){ signal input in[n]; signal out <== A(n)( a <== in[0], b <-- in[1]); } component main = B(2); The value returned by the anonymous components depends on the number of template's output signals. If the template does not define any output signal (for instance, if it only defines constraints based on the input signals), we can use the anonymous component like if it was an statement temp_name(arg1,...,argN)(inp1,...,inpM); If the template defines a single output signal , we can use any of the well-known operators to collect the output signal. It is important to highlight that we can use with the anonymous components any of the operators <-- , <== , = , --> and ==> with the usual semantics. For instance, signal out <== temp_name(a1,...,aN)(i1,...,iM); If the template defines more than an output signal , we need to use a new kind of expression to collect all the outputs: the tuples , whose syntax is the usual in other programming languages. signal output o1, ..., oK; (o1,...,oK) <== temp_name(a1,...,aN)(i1,...,iM); var v1, ..., vK; (v1,...,vK) = temp_name(a1,...,aN)(i1,...,iM); The use of tuples Tuples are a typical expression in other programming languages, which allows us to do multiple assignments like in the previous example. We have introduced tuples because of the previous feature. When using templates with several outputs is necessary being able to collect all the outputs at the same time, since the component is anonymous and later cannot be accessed. Apart from the main use of the tuples, we can use this new kind of expressions with every kind of assignment <== , = and <-- . However, we discourage the use of the latter. Tuples can only be used in combination of any of these operators whenever there are tuples in both sides of the statement. In this case, the semantics of this multiple assignment is the element-wise assignment. Let us see a non-trivial example to illustrate the importance of the order of the tuple elements. var a = 0, b = 0; component c; (a, b, c) = (1,a+1, A(2)); This is internally translated by the compiler to a = 1; b = a + 1; c = A(2); Then, the final value of a and b is 1 and 2, respectively. Notice that c is an instance of template A and we could use now statements to access its inputs and outputs. The use of <== for signal arrays One more extension must be added to circom in order to enable the use of anonymous components. How could we use a template as anonymous component if it makes use of input/output signal arrays? So far, this could not be handled by circom. In circom 2.1.0, we have overloaded the operator <== for signal arrays with the same dimension to express the element-wise assignment. For instance, let us consider the next code. template Ex(n,m){ signal input in[n]; signal output out[m]; out <== in; } If n != m , then the compiler reports an error, since both arrays have not the same size. Otherwise, the code is equivalent to: template Ex(n,m){ signal input in[n]; signal output out[m]; while(i < 4){ out[i] <== in[i]; i += 1; } } Let us use this template to illustrate how this new feature is combined with the use of an anonymous component. template A{ signal input i[4]; signal output o[4]; o <== Ex(4,4)(i); } Here, we can see that we pass as first signal parameter a 4-size array. Notice that previously we can only write a program similar to: template A{ signal input i[4]; signal output o[4]; component anon = Ex(4,4); var i = 0; while(i < 4){ anon.in[i] <== i[i]; i += 1; } i = 0; while(i < 4){ o[i] <== anon.out[i]; i += 1; } } The use of _ The underscore \"_\" allows to ignore any amount of output signals of the anonymous components. template A(n){ signal input a, b, c; signal output d; d <== a*b+c; a * b === c*c; } template B(n){ signal input in[n]; _ <== A(n)(in[0],in[1],in[2]); } component main = B(3); In the previous example, we are interesting in adding to the R1CS the constraint a * b = c * c , but we can ignore the output signal d . In case the anonymous component has one more than one output, we can ignore the ones we are not interested. template A(n){ signal input a; signal output b, c, d; b <== a * a; c <== a + 2; d <== a * a + 2; } template B(n){ signal input in; signal output out1; (_,out1,_) <== A(n)(in); } component main = B(3); In this example, we are only interested in out1 = in + 2 .","title":"Tuples and Anonymous Components"},{"location":"circom-language/anonymous-components-and-tuples/#tuples-and-anonymous-components","text":"","title":"Tuples and Anonymous Components"},{"location":"circom-language/anonymous-components-and-tuples/#anonymous-components","text":"circom 2.1.0 introduces a new feature called anonymous component . An anonymous component allows in a single instruction 1) the implicit declaration of a new component, 2) the assignment of every input signal and, finally, 3) the assignment of every output signal. This section is divided in the next subsections: 1. Syntax and semantics of anonymous components . 2. What if the anonymous component is an instance of a template with more than an output signal? We introduce the tuples in circom. 3. What if the anonymous component is an instance of a template which input/output signals are arrays? We introduce the element-wise assignment for signal arrays. 4. What if we are not interested in collecting one of the outputs? We introduce the use of \"_\" to indicate that a signal is not relevant.","title":"Anonymous Components"},{"location":"circom-language/anonymous-components-and-tuples/#syntax-and-semantics-of-anonymous-components","text":"Let us see a typical circom program. template A(n){ signal input a, b; signal output c; c <== a*b; } template B(n){ signal input in[n]; signal out; component temp_a = A(n); temp_a.a <== in[0]; temp_a.b <== in[1]; out <== temp_a.c; } component main = B(2); Thanks to the use of anonymous components, we can easily write the next program, which is, equivalent to the previous one, but its code is much cleaner. template A(n){ signal input a, b; signal output c; c <== a*b; } template B(n){ signal input in[n]; signal out <== A(n)(in[0],in[1]); } component main = B(2); It is important to highlight that both circuits are equivalent: they have the same witnesses and the same constraint, that is, out === in[0]*in[1] . The anonymous components are a new kind of circom expression whose syntax is as follows: temp_name(arg1,...,argN)(input1,...,inputM) assuming that we have a template temp_name with N arguments and M input signals. Let us clarify two points: 1. arg1 , ..., argN are template arguments. We can use them as usual. They can be arithmetic operations expressions or constants. The important thing is its value must be known at compilation time. 2. input1 , ..., inputM are input signals. We can pass another signals, (just like in the example) constants or other anonymous components (in a compositional way), if and only if, such components only have 1 output signal . The order of the signals in the anonymous component matters: the ith input signal receives the value of the ith signal passed as parameter. Since circom 2.1.1, it is also allowed to indicate the name of the input signal corresponding to each parameter, followed by <== or <-- and, finally, the signal which gives the value). The only condition that must be satisfied is that all the subcomponent inputs must receive a value. Let us see this new feature in the previous example: template A(n){ signal input a, b; signal output c; c <== a*b; } template B(n){ signal input in[n]; signal out <== A(n)( a <== in[0], b <-- in[1]); } component main = B(2); The value returned by the anonymous components depends on the number of template's output signals. If the template does not define any output signal (for instance, if it only defines constraints based on the input signals), we can use the anonymous component like if it was an statement temp_name(arg1,...,argN)(inp1,...,inpM); If the template defines a single output signal , we can use any of the well-known operators to collect the output signal. It is important to highlight that we can use with the anonymous components any of the operators <-- , <== , = , --> and ==> with the usual semantics. For instance, signal out <== temp_name(a1,...,aN)(i1,...,iM); If the template defines more than an output signal , we need to use a new kind of expression to collect all the outputs: the tuples , whose syntax is the usual in other programming languages. signal output o1, ..., oK; (o1,...,oK) <== temp_name(a1,...,aN)(i1,...,iM); var v1, ..., vK; (v1,...,vK) = temp_name(a1,...,aN)(i1,...,iM);","title":"Syntax and semantics of anonymous components"},{"location":"circom-language/anonymous-components-and-tuples/#the-use-of-tuples","text":"Tuples are a typical expression in other programming languages, which allows us to do multiple assignments like in the previous example. We have introduced tuples because of the previous feature. When using templates with several outputs is necessary being able to collect all the outputs at the same time, since the component is anonymous and later cannot be accessed. Apart from the main use of the tuples, we can use this new kind of expressions with every kind of assignment <== , = and <-- . However, we discourage the use of the latter. Tuples can only be used in combination of any of these operators whenever there are tuples in both sides of the statement. In this case, the semantics of this multiple assignment is the element-wise assignment. Let us see a non-trivial example to illustrate the importance of the order of the tuple elements. var a = 0, b = 0; component c; (a, b, c) = (1,a+1, A(2)); This is internally translated by the compiler to a = 1; b = a + 1; c = A(2); Then, the final value of a and b is 1 and 2, respectively. Notice that c is an instance of template A and we could use now statements to access its inputs and outputs.","title":"The use of tuples"},{"location":"circom-language/anonymous-components-and-tuples/#the-use-of-for-signal-arrays","text":"One more extension must be added to circom in order to enable the use of anonymous components. How could we use a template as anonymous component if it makes use of input/output signal arrays? So far, this could not be handled by circom. In circom 2.1.0, we have overloaded the operator <== for signal arrays with the same dimension to express the element-wise assignment. For instance, let us consider the next code. template Ex(n,m){ signal input in[n]; signal output out[m]; out <== in; } If n != m , then the compiler reports an error, since both arrays have not the same size. Otherwise, the code is equivalent to: template Ex(n,m){ signal input in[n]; signal output out[m]; while(i < 4){ out[i] <== in[i]; i += 1; } } Let us use this template to illustrate how this new feature is combined with the use of an anonymous component. template A{ signal input i[4]; signal output o[4]; o <== Ex(4,4)(i); } Here, we can see that we pass as first signal parameter a 4-size array. Notice that previously we can only write a program similar to: template A{ signal input i[4]; signal output o[4]; component anon = Ex(4,4); var i = 0; while(i < 4){ anon.in[i] <== i[i]; i += 1; } i = 0; while(i < 4){ o[i] <== anon.out[i]; i += 1; } }","title":"The use of &lt;== for signal arrays"},{"location":"circom-language/anonymous-components-and-tuples/#the-use-of-_","text":"The underscore \"_\" allows to ignore any amount of output signals of the anonymous components. template A(n){ signal input a, b, c; signal output d; d <== a*b+c; a * b === c*c; } template B(n){ signal input in[n]; _ <== A(n)(in[0],in[1],in[2]); } component main = B(3); In the previous example, we are interesting in adding to the R1CS the constraint a * b = c * c , but we can ignore the output signal d . In case the anonymous component has one more than one output, we can ignore the ones we are not interested. template A(n){ signal input a; signal output b, c, d; b <== a * a; c <== a + 2; d <== a * a + 2; } template B(n){ signal input in; signal output out1; (_,out1,_) <== A(n)(in); } component main = B(3); In this example, we are only interested in out1 = in + 2 .","title":"The use of _"},{"location":"circom-language/basic-operators/","text":"Basic Operators Circom provides boolean, arithmetic, and bitwise operators. They have the standard semantics but the arithmetic operators applied to numeric values work modulo p. The precedence and association of the operators are like in Rust (defined here ). Expressions can be built using the next operators, but the conditional operator ?_:_ can only occur at the top level. Field Elements A field element is a value in the domain of Z/pZ, where p is the prime number set by default to p = 21888242871839275222246405745257275088548364400416034343698204186575808495617. As such, field elements are operated in arithmetic modulo p. The circom language is parametric to this number, and it can be changed without affecting the rest of the language (using GLOBAL_FIELD_P ). Conditional expressions Boolean_condition ? true_value : false_value var z = x>y? x : y; This conditional expression is not allowed in a nested form, hence can only be used at the top level. Boolean operators Next boolean operators are allowed: Operator Example Explanation && a && b Boolean operator AND || a || b Boolean operator OR ! ! a Boolean operator NEGATION Relational operators The definition of relational operators < , > , <= , >= , == , != depends on the mathematical function val(x) which is defined as follows: val(z) = z-p if p/2 +1 <= z < p val(z) = z, otherwise. According to this function, the definition of the relational operators is as follows: `x < y` is defined as val(x % p) < val(y % p) `x > y` is defined as val(x % p) > val(y % p) `x <= y` is defined as val(x % p) <= val(y % p) `x >= y` is defined as val(x % p) >= val(y % p) where <, >, <=, >= are the comparison of integers. Arithmetic operators All arithmetic operations work modulo p. We have the next operators: Operator Example Explanation + a + b Arithmetic addition modulo p - a - b Arithmetic subtraction modulo p * a * b Arithmetic multiplication modulo p ** a ** b Power modulo p / a / b Multiplication by the inverse modulo p \\ a \\ b Quotient of the integer division % a % b Remainder of the integer division There are operators that combine arithmetic operators with a final assignment. Operator Example Explanation += a += b Arithmetic addition modulo p and assignment -= a -= b Arithmetic subtraction modulo p and assignment *= a *= b Arithmetic multiplication modulo p and assignment **= a ** b Power modulo p and assignment /= a /= b Multiplication by the inverse modulo p and assignment \\= a \\= b Quotient of the integer division and assignment %= a %= b Remainder of the integer division and assignment ++ a++ Unit increment. Syntactic sugar for a += 1 -- a-- Unit decrement. Syntactic sugar for a -= 1 Bitwise operators All bitwise operators are performed modulo p. Operator Example Explanation & a & b Bitwise AND | a | b Bitwise OR ~ ~a Complement 254 bits ^ a ^ b XOR 254 bits >> a >> 4 Right shift operator << a << 4 Left shift operator The shift operations also work modulo p and are defined as follows (assuming p>=7). For all k with 0=< k <= p/2 (integer division) we have that x >> k = x/(2**k) x << k = (x*(2{**}k)~ & ~mask) % p where b is the number of significant bits of p and mask is 2{**}b - 1 . For all k with p/2 +1<= k < p we have that x >> k = x << (p-k) x << k = x >> (p-k) note that k is also the negative number k-p . There are operators that combine bitwise operators with a final assignment. Operator Example Explanation &= a &= b Bitwise AND and assignment |= a |= b Bitwise OR and assignment ~= ~=a Complement 254 bits and assignment ^= a ^= b XOR 254 bits and assignment >>= a >>= 4 Right shift operator and assignment <<= a <<= 4 Left shift operator and assignment Examples using operators from the circom library In the following, there are several examples using combinations of the previous operators. pragma circom 2.0.0; template IsZero() { signal input in; signal output out; signal inv; inv <-- in!=0 ? 1/in : 0; out <== -in*inv +1; in*out === 0; } component main {public [in]}= IsZero(); This template checks if the input signal in is 0 . In case it is, the value of output signal out is 1 . 0 , otherwise. Note here that we use the intermediate signal inv to compute the inverse of the value of in or 0 if it does not exist. If in is 0, then in*inv is 0, and the value of out is 1 . Otherwise, in*inv is always 1 , then out is 0 . pragma circom 2.0.0; template Num2Bits(n) { signal input in; signal output out[n]; var lc1=0; var e2=1; for (var i = 0; i<n; i++) { out[i] <-- (in >> i) & 1; out[i] * (out[i] -1 ) === 0; lc1 += out[i] * e2; e2 = e2+e2; } lc1 === in; } component main {public [in]}= Num2Bits(3); This templates returns a n-dimensional array with the value of in in binary. Line 7 uses the right shift >> and operator & to obtain at each iteration the i component of the array. Finally, line 12 adds the constraint lc1 = in to guarantee that the conversion is well done.","title":"Basic Operators"},{"location":"circom-language/basic-operators/#basic-operators","text":"Circom provides boolean, arithmetic, and bitwise operators. They have the standard semantics but the arithmetic operators applied to numeric values work modulo p. The precedence and association of the operators are like in Rust (defined here ). Expressions can be built using the next operators, but the conditional operator ?_:_ can only occur at the top level.","title":"Basic Operators"},{"location":"circom-language/basic-operators/#field-elements","text":"A field element is a value in the domain of Z/pZ, where p is the prime number set by default to p = 21888242871839275222246405745257275088548364400416034343698204186575808495617. As such, field elements are operated in arithmetic modulo p. The circom language is parametric to this number, and it can be changed without affecting the rest of the language (using GLOBAL_FIELD_P ).","title":"Field Elements"},{"location":"circom-language/basic-operators/#conditional-expressions","text":"Boolean_condition ? true_value : false_value var z = x>y? x : y; This conditional expression is not allowed in a nested form, hence can only be used at the top level.","title":"Conditional expressions"},{"location":"circom-language/basic-operators/#boolean-operators","text":"Next boolean operators are allowed: Operator Example Explanation && a && b Boolean operator AND || a || b Boolean operator OR ! ! a Boolean operator NEGATION","title":"Boolean operators"},{"location":"circom-language/basic-operators/#relational-operators","text":"The definition of relational operators < , > , <= , >= , == , != depends on the mathematical function val(x) which is defined as follows: val(z) = z-p if p/2 +1 <= z < p val(z) = z, otherwise. According to this function, the definition of the relational operators is as follows: `x < y` is defined as val(x % p) < val(y % p) `x > y` is defined as val(x % p) > val(y % p) `x <= y` is defined as val(x % p) <= val(y % p) `x >= y` is defined as val(x % p) >= val(y % p) where <, >, <=, >= are the comparison of integers.","title":"Relational operators"},{"location":"circom-language/basic-operators/#arithmetic-operators","text":"All arithmetic operations work modulo p. We have the next operators: Operator Example Explanation + a + b Arithmetic addition modulo p - a - b Arithmetic subtraction modulo p * a * b Arithmetic multiplication modulo p ** a ** b Power modulo p / a / b Multiplication by the inverse modulo p \\ a \\ b Quotient of the integer division % a % b Remainder of the integer division There are operators that combine arithmetic operators with a final assignment. Operator Example Explanation += a += b Arithmetic addition modulo p and assignment -= a -= b Arithmetic subtraction modulo p and assignment *= a *= b Arithmetic multiplication modulo p and assignment **= a ** b Power modulo p and assignment /= a /= b Multiplication by the inverse modulo p and assignment \\= a \\= b Quotient of the integer division and assignment %= a %= b Remainder of the integer division and assignment ++ a++ Unit increment. Syntactic sugar for a += 1 -- a-- Unit decrement. Syntactic sugar for a -= 1","title":"Arithmetic operators"},{"location":"circom-language/basic-operators/#bitwise-operators","text":"All bitwise operators are performed modulo p. Operator Example Explanation & a & b Bitwise AND | a | b Bitwise OR ~ ~a Complement 254 bits ^ a ^ b XOR 254 bits >> a >> 4 Right shift operator << a << 4 Left shift operator The shift operations also work modulo p and are defined as follows (assuming p>=7). For all k with 0=< k <= p/2 (integer division) we have that x >> k = x/(2**k) x << k = (x*(2{**}k)~ & ~mask) % p where b is the number of significant bits of p and mask is 2{**}b - 1 . For all k with p/2 +1<= k < p we have that x >> k = x << (p-k) x << k = x >> (p-k) note that k is also the negative number k-p . There are operators that combine bitwise operators with a final assignment. Operator Example Explanation &= a &= b Bitwise AND and assignment |= a |= b Bitwise OR and assignment ~= ~=a Complement 254 bits and assignment ^= a ^= b XOR 254 bits and assignment >>= a >>= 4 Right shift operator and assignment <<= a <<= 4 Left shift operator and assignment","title":"Bitwise operators"},{"location":"circom-language/basic-operators/#examples-using-operators-from-the-circom-library","text":"In the following, there are several examples using combinations of the previous operators. pragma circom 2.0.0; template IsZero() { signal input in; signal output out; signal inv; inv <-- in!=0 ? 1/in : 0; out <== -in*inv +1; in*out === 0; } component main {public [in]}= IsZero(); This template checks if the input signal in is 0 . In case it is, the value of output signal out is 1 . 0 , otherwise. Note here that we use the intermediate signal inv to compute the inverse of the value of in or 0 if it does not exist. If in is 0, then in*inv is 0, and the value of out is 1 . Otherwise, in*inv is always 1 , then out is 0 . pragma circom 2.0.0; template Num2Bits(n) { signal input in; signal output out[n]; var lc1=0; var e2=1; for (var i = 0; i<n; i++) { out[i] <-- (in >> i) & 1; out[i] * (out[i] -1 ) === 0; lc1 += out[i] * e2; e2 = e2+e2; } lc1 === in; } component main {public [in]}= Num2Bits(3); This templates returns a n-dimensional array with the value of in in binary. Line 7 uses the right shift >> and operator & to obtain at each iteration the i component of the array. Finally, line 12 adds the constraint lc1 = in to guarantee that the conversion is well done.","title":"Examples using operators from the circom library"},{"location":"circom-language/comment-lines/","text":"Comment Lines In circom, you can place comments in your source code. These comment lines will be ignored by the compiler. Comments help programmer reading your source code to better understand it. Adding comments to your code is a highly recommended practice. The comment lines allowed in circom 2.0 are similar to other programming languages like C or C++. You can write comments on a single line by using // : //Using this, we can comment a line. You can also write a comment at the end of a code line using // : template example(){ signal input in; //This is an input signal. signal output out; //This is an output signal. } Finally, you can write comments that span multiple lines using /* and */ : /* All these lines will be ignored by the compiler. */","title":"Comment Lines"},{"location":"circom-language/comment-lines/#comment-lines","text":"In circom, you can place comments in your source code. These comment lines will be ignored by the compiler. Comments help programmer reading your source code to better understand it. Adding comments to your code is a highly recommended practice. The comment lines allowed in circom 2.0 are similar to other programming languages like C or C++. You can write comments on a single line by using // : //Using this, we can comment a line. You can also write a comment at the end of a code line using // : template example(){ signal input in; //This is an input signal. signal output out; //This is an output signal. } Finally, you can write comments that span multiple lines using /* and */ : /* All these lines will be ignored by the compiler. */","title":"Comment Lines"},{"location":"circom-language/constraint-generation/","text":"Constraint Generation To understand the constructive part of circom, we need to consider the following type of expressions: Constant values : only a constant value is allowed. Linear expression : an expression where only addition is used. It can also be written using multiplication of variables by constants. For instance, the expression 2*x + 3*y + 2 is allowed, as it is equivalent to x + x + y + y + y + 2 . Quadratic expression : it is obtained by allowing a multiplication between two linear expressions and addition of a linear expression: A*B - C, where A, B and C are linear expressions. For instance, (2*x + 3*y + 2) * (x+y) + 6*x + y \u2013 2 . Non quadratic expressions : any arithmetic expression which is not of the previous kind. circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A*B + C = 0, where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A*B + C = 0: Moves from one side of the equality to the other. Applications of commutativity of addition. Multiplication (or division) by constants. A constraint is imposed with the operator === , which creates the simplified form of the given equality constraint. a*(a-1) === 0; Adding such constraint also implies adding an assert statement in the witness code generation. Constraint generation can be combined with signal assignment with the operator <== with the signal to be assigned on the left hand side of the operator. out <== 1 - a*b; Which is equivalent to: out === 1 \u2013 a*b; out <-- 1 - a*b; As mentioned before, assigning a value to a signal using <-- and --> is considered dangerous and should, in general, be combined with adding constraints with === , which describe by means of constraints which the assigned values are. For example: a <-- b/c; a*c === b; In the constructive phase, a variable can contain arithmetic expressions that are built using multiplication, addition, and other variables or signals and field values. Only quadratic expressions are allowed to be included in constraints. Other arithmetic expressions beyond quadratic or using other arithmetic operators like division or power are not allowed as constraints. template multi3() { signal input in; signal input in2; signal input in3; signal output out; out <== in*in2*in3; } This template produces the error \"Non quadratic constraints are not allowed!\", since it introduces the constraint out === in*in2*in3 which is NOT quadratic. The following example shows the generation of expressions: signal input a; signal output b; var x = a*a; x += 3; b <== x; The last instruction produces the constraint b === a * a + 3 . Finally, programmers sometimes misuse operator <-- , when starting to work in circom. They usually assign using this operator an expression which is quadratic and, as a consequence, no constraint is added. In this case, the operator needed to both performing the assignment and adding the constraint is operator <== . Since version 2.0.8, we throw a warning in this case.","title":"Constraint Generation"},{"location":"circom-language/constraint-generation/#constraint-generation","text":"To understand the constructive part of circom, we need to consider the following type of expressions: Constant values : only a constant value is allowed. Linear expression : an expression where only addition is used. It can also be written using multiplication of variables by constants. For instance, the expression 2*x + 3*y + 2 is allowed, as it is equivalent to x + x + y + y + y + 2 . Quadratic expression : it is obtained by allowing a multiplication between two linear expressions and addition of a linear expression: A*B - C, where A, B and C are linear expressions. For instance, (2*x + 3*y + 2) * (x+y) + 6*x + y \u2013 2 . Non quadratic expressions : any arithmetic expression which is not of the previous kind. circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A*B + C = 0, where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A*B + C = 0: Moves from one side of the equality to the other. Applications of commutativity of addition. Multiplication (or division) by constants. A constraint is imposed with the operator === , which creates the simplified form of the given equality constraint. a*(a-1) === 0; Adding such constraint also implies adding an assert statement in the witness code generation. Constraint generation can be combined with signal assignment with the operator <== with the signal to be assigned on the left hand side of the operator. out <== 1 - a*b; Which is equivalent to: out === 1 \u2013 a*b; out <-- 1 - a*b; As mentioned before, assigning a value to a signal using <-- and --> is considered dangerous and should, in general, be combined with adding constraints with === , which describe by means of constraints which the assigned values are. For example: a <-- b/c; a*c === b; In the constructive phase, a variable can contain arithmetic expressions that are built using multiplication, addition, and other variables or signals and field values. Only quadratic expressions are allowed to be included in constraints. Other arithmetic expressions beyond quadratic or using other arithmetic operators like division or power are not allowed as constraints. template multi3() { signal input in; signal input in2; signal input in3; signal output out; out <== in*in2*in3; } This template produces the error \"Non quadratic constraints are not allowed!\", since it introduces the constraint out === in*in2*in3 which is NOT quadratic. The following example shows the generation of expressions: signal input a; signal output b; var x = a*a; x += 3; b <== x; The last instruction produces the constraint b === a * a + 3 . Finally, programmers sometimes misuse operator <-- , when starting to work in circom. They usually assign using this operator an expression which is quadratic and, as a consequence, no constraint is added. In this case, the operator needed to both performing the assignment and adding the constraint is operator <== . Since version 2.0.8, we throw a warning in this case.","title":"Constraint Generation"},{"location":"circom-language/control-flow/","text":"Control Flow We have standard constructions for defining the control flow of the program. Conditional statement: if-then-else if ( boolean_condition ) block_of_code else block_of_code The else part is optional. When omitted, it means \u201celse do nothing\u201d. var x = 0; var y = 1; if (x >= 0) { x = y + 1; y += 1; } else { y = x; } Loop statement: for for ( initialization_code ; boolean_condition ; step_code ) block_of_code If the initialization_code includes a var declaration then its scope is reduced to the for statement and hence, using it later on (without defining it again) will produce a compilation error. var y = 0; for(var i = 0; i < 100; i++){ y++; } Loop statement: while while ( boolean_condition ) block_of_code It executes the block of code while the condition holds. The condition is checked every time before executing the block of code. var y = 0; var i = 0; while(i < 100){ i++; y += y; } Important : when constraints are generated in any block inside an if-then-else or loop statement, the condition cannot be unknown (see Unknowns ). This is because the constraint generation must be unique and cannot depend on unknown input signals. In case the expression in the condition is unknown and some constraint is generated, the compiler will generate the next error message: \" There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase \". pragma circom 2.0.0; template A(){} template wrong(N1){ signal input in; component c; if(in > N1){ c = A(); } } component main {public [in]} = wrong(1); In this example, the condition depends on the input signal in whose value is unknown at compilation time. Let us also notice that if the body of the statement does not involve any signal or component; or a constraint does not depend on a value involved with unknown values, then the compilation will succeed as it can be seen in the next example. template right(N){ signal input in; var x = 2; var t = 5; if(in > N){ t = 2; } } This template is correct, since no constraint depends on the unknown value of in . template right(N1,N2){ signal input in; var x = 2; var t = 5; if(N1 > N2){ t = 2; } x === t; } This template is correct since the values of variables involved in the constraint only depend on known values of parameter N1 and N2 . Important : Another compilation error is generated when the content of a var depends on some unknown condition: that is when the var takes its value inside an if-then-else or loop statement with an unknown condition. Then, the content of the variable is a non-quadratic expression and, as such, cannot be used in the generation of a constraint. template wrong(){ signal input in; var x; var t = 5; if(in > 3){ t = 2; } x === t; } This template produces a compilation error, since the value of variable t involved in the last constraint depends on the unknown value of variable in . The control flow of the computations is like in other imperative languages, but the instantiation of components may not follow the sequential structure of the code because component instantiation will not be triggered until all input signals have a concrete value assigned. template mult(){ signal input in[2]; signal output out; out <== in[0] * in[1]; } template mult4(){ signal input in[4]; component comp1 = mult(); component comp2 = mult(); comp1.in[0] = in[0]; comp2.in[0] = in[1]; comp2.in[1] = in[2]; comp1.in[1] = in[3]; } In this example, comp2 is instantiated before comp1 , since comp2 's input signals have concrete values before comp1 's input signals. Consequently, comp2.out obtains the value after the execution of line 13, whereas comp1.out obtains it after the execution of line 14.","title":"Control Flow"},{"location":"circom-language/control-flow/#control-flow","text":"We have standard constructions for defining the control flow of the program.","title":"Control Flow"},{"location":"circom-language/control-flow/#conditional-statement-if-then-else","text":"if ( boolean_condition ) block_of_code else block_of_code The else part is optional. When omitted, it means \u201celse do nothing\u201d. var x = 0; var y = 1; if (x >= 0) { x = y + 1; y += 1; } else { y = x; }","title":"Conditional statement: if-then-else"},{"location":"circom-language/control-flow/#loop-statement-for","text":"for ( initialization_code ; boolean_condition ; step_code ) block_of_code If the initialization_code includes a var declaration then its scope is reduced to the for statement and hence, using it later on (without defining it again) will produce a compilation error. var y = 0; for(var i = 0; i < 100; i++){ y++; }","title":"Loop statement: for"},{"location":"circom-language/control-flow/#loop-statement-while","text":"while ( boolean_condition ) block_of_code It executes the block of code while the condition holds. The condition is checked every time before executing the block of code. var y = 0; var i = 0; while(i < 100){ i++; y += y; } Important : when constraints are generated in any block inside an if-then-else or loop statement, the condition cannot be unknown (see Unknowns ). This is because the constraint generation must be unique and cannot depend on unknown input signals. In case the expression in the condition is unknown and some constraint is generated, the compiler will generate the next error message: \" There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase \". pragma circom 2.0.0; template A(){} template wrong(N1){ signal input in; component c; if(in > N1){ c = A(); } } component main {public [in]} = wrong(1); In this example, the condition depends on the input signal in whose value is unknown at compilation time. Let us also notice that if the body of the statement does not involve any signal or component; or a constraint does not depend on a value involved with unknown values, then the compilation will succeed as it can be seen in the next example. template right(N){ signal input in; var x = 2; var t = 5; if(in > N){ t = 2; } } This template is correct, since no constraint depends on the unknown value of in . template right(N1,N2){ signal input in; var x = 2; var t = 5; if(N1 > N2){ t = 2; } x === t; } This template is correct since the values of variables involved in the constraint only depend on known values of parameter N1 and N2 . Important : Another compilation error is generated when the content of a var depends on some unknown condition: that is when the var takes its value inside an if-then-else or loop statement with an unknown condition. Then, the content of the variable is a non-quadratic expression and, as such, cannot be used in the generation of a constraint. template wrong(){ signal input in; var x; var t = 5; if(in > 3){ t = 2; } x === t; } This template produces a compilation error, since the value of variable t involved in the last constraint depends on the unknown value of variable in . The control flow of the computations is like in other imperative languages, but the instantiation of components may not follow the sequential structure of the code because component instantiation will not be triggered until all input signals have a concrete value assigned. template mult(){ signal input in[2]; signal output out; out <== in[0] * in[1]; } template mult4(){ signal input in[4]; component comp1 = mult(); component comp2 = mult(); comp1.in[0] = in[0]; comp2.in[0] = in[1]; comp2.in[1] = in[2]; comp1.in[1] = in[3]; } In this example, comp2 is instantiated before comp1 , since comp2 's input signals have concrete values before comp1 's input signals. Consequently, comp2.out obtains the value after the execution of line 13, whereas comp1.out obtains it after the execution of line 14.","title":"Loop statement: while"},{"location":"circom-language/custom-templates-snarkjs/","text":"Custom templates in snarkjs snarkjs provides an implementation of the PLONK's zkSNARK. An extension of the scheme, turbo-PLONK , allows the definition of the so called custom gates: more general transition gates than the ones defined by default for the regular PLONK zkSNARK, that allows the circuit's designer to, maybe, reduce the number of used gates, probably resulting in shorter proofs size or verification times. This document will contain a list of the custom gates implemented in snarkjs that can me used in the circom language. Note that the list may grow over time with the new implementations from the iden3 collaborators or thanks to contributions from the community. List of custom gates implemented in snarkjs At the moment there are no custom gates implemented in snarkjs yet.","title":"Custom templates in [snarkjs](../index.md#snarkjs)"},{"location":"circom-language/custom-templates-snarkjs/#custom-templates-in-snarkjs","text":"snarkjs provides an implementation of the PLONK's zkSNARK. An extension of the scheme, turbo-PLONK , allows the definition of the so called custom gates: more general transition gates than the ones defined by default for the regular PLONK zkSNARK, that allows the circuit's designer to, maybe, reduce the number of used gates, probably resulting in shorter proofs size or verification times. This document will contain a list of the custom gates implemented in snarkjs that can me used in the circom language. Note that the list may grow over time with the new implementations from the iden3 collaborators or thanks to contributions from the community.","title":"Custom templates in snarkjs"},{"location":"circom-language/custom-templates-snarkjs/#list-of-custom-gates-implemented-in-snarkjs","text":"At the moment there are no custom gates implemented in snarkjs yet.","title":"List of custom gates implemented in snarkjs"},{"location":"circom-language/data-types/","text":"Data types The basic var types in circom are: Field element values : integer values modulo the prime number p (see Signals ). This is the default type for all signals and basic variables. Arrays : they can hold a finite number of elements (known at compilation time) of the same type (signal, var, or the same type of components or arrays again). The elements are numbered from zero on and can be accessed using the corresponding index of their position. Array access is made using square brackets. Declaration of an array of a given type is made by adding [] aside of the variable identifier and including the size between the brackets (which should be defined using constant values and/or numeric parameters of templates). The access and the declaration should be consistent with their type and hence we access and declare with m[i][j], since m[i] is an array. Examples of declarations with and without initialization: var x[3] = [2,8,4]; var z[n+1]; // where n is a parameter of a template var dbl[16][2] = base; var y[5] = someFunction(n); The notation m[i,j] for arrays of arrays (matrices) is not allowed. On the other hand, the following case will produce a compilation error, since the size of the array should be explicitly given; var z = [2,8,4]; Finally, the type of signals needs to be declared as they cannot be assigned globally as an array. They are assigned by position. signal input in[3]; signal output out[2]; signal intermediate[4]; An array of components must be instantiated with the same template with (optionally) different parameters. pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ c[i] = fun(i); } } component main = all(5); Consequently, the next code will produce the following compilation error: \" c[i] = fun \\(i\\) -> Assignee and assigned types do not match\". pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template fun2(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ if(i < N) c[i] = fun(i); else c[i] = fun2(i); } } component main = all(5);","title":"Data Types"},{"location":"circom-language/data-types/#data-types","text":"The basic var types in circom are: Field element values : integer values modulo the prime number p (see Signals ). This is the default type for all signals and basic variables. Arrays : they can hold a finite number of elements (known at compilation time) of the same type (signal, var, or the same type of components or arrays again). The elements are numbered from zero on and can be accessed using the corresponding index of their position. Array access is made using square brackets. Declaration of an array of a given type is made by adding [] aside of the variable identifier and including the size between the brackets (which should be defined using constant values and/or numeric parameters of templates). The access and the declaration should be consistent with their type and hence we access and declare with m[i][j], since m[i] is an array. Examples of declarations with and without initialization: var x[3] = [2,8,4]; var z[n+1]; // where n is a parameter of a template var dbl[16][2] = base; var y[5] = someFunction(n); The notation m[i,j] for arrays of arrays (matrices) is not allowed. On the other hand, the following case will produce a compilation error, since the size of the array should be explicitly given; var z = [2,8,4]; Finally, the type of signals needs to be declared as they cannot be assigned globally as an array. They are assigned by position. signal input in[3]; signal output out[2]; signal intermediate[4]; An array of components must be instantiated with the same template with (optionally) different parameters. pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ c[i] = fun(i); } } component main = all(5); Consequently, the next code will produce the following compilation error: \" c[i] = fun \\(i\\) -> Assignee and assigned types do not match\". pragma circom 2.0.0; template fun(N){ signal output out; out <== N; } template fun2(N){ signal output out; out <== N; } template all(N){ component c[N]; for(var i = 0; i < N; i++){ if(i < N) c[i] = fun(i); else c[i] = fun2(i); } } component main = all(5);","title":"Data types"},{"location":"circom-language/functions/","text":"Functions In circom, functions define generic abstract pieces of code that can perform some computations to obtain a value or an expression to be returned. function funid ( param1, ... , paramn ) { ..... return x; } Functions compute numeric (or arrays of) values or expressions. Functions can be recursive. Consider the next function from the circom library. /* This function calculates the number of extra bits in the output to do the full sum. */ function nbits(a) { var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } return r; } Functions cannot declare signals or generate constraints (use templates if you need so). The next function produces the error message: \"Template operator found\". function nbits(a) { signal input in; //This is not allowed. var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } r === a; //This is also not allowed. return r; } As usual, there can be many return statements, but every execution trace must end in a return statement (otherwise, a compile error will be produced). The execution of the return statement returns the control to the caller of the function. function example(N){ if(N >= 0){ return 1;} // else{ return 0;} } The compilation of function example produces the next error message: \"In example there are paths without return\".","title":"Functions"},{"location":"circom-language/functions/#functions","text":"In circom, functions define generic abstract pieces of code that can perform some computations to obtain a value or an expression to be returned. function funid ( param1, ... , paramn ) { ..... return x; } Functions compute numeric (or arrays of) values or expressions. Functions can be recursive. Consider the next function from the circom library. /* This function calculates the number of extra bits in the output to do the full sum. */ function nbits(a) { var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } return r; } Functions cannot declare signals or generate constraints (use templates if you need so). The next function produces the error message: \"Template operator found\". function nbits(a) { signal input in; //This is not allowed. var n = 1; var r = 0; while (n-1<a) { r++; n *= 2; } r === a; //This is also not allowed. return r; } As usual, there can be many return statements, but every execution trace must end in a return statement (otherwise, a compile error will be produced). The execution of the return statement returns the control to the caller of the function. function example(N){ if(N >= 0){ return 1;} // else{ return 0;} } The compilation of function example produces the next error message: \"In example there are paths without return\".","title":"Functions"},{"location":"circom-language/identifiers/","text":"Identifiers Any non-reserved keyword that starts with any number of \u201c_ \u201d followed by an ASCII alphabetic character and followed by any number of alphabetic or numeric chars, \u201c_\u201d or \u201c$\u201d can be used as identifier. Examples of identifiers are the following: signal input _in; var o_u_t; var o$o;","title":"Identifiers"},{"location":"circom-language/identifiers/#identifiers","text":"Any non-reserved keyword that starts with any number of \u201c_ \u201d followed by an ASCII alphabetic character and followed by any number of alphabetic or numeric chars, \u201c_\u201d or \u201c$\u201d can be used as identifier. Examples of identifiers are the following: signal input _in; var o_u_t; var o$o;","title":"Identifiers"},{"location":"circom-language/include/","text":"Include Templates, like other code, can be found in other files like in libraries. In order to use code in other files, we have to include them in our program by using the keyword include, with the corresponding name of the file (.circom extension is the default). include \"montgomery.circom\"; include \"mux3.circom\"; include \"babyjub.circom\"; This piece of code includes the files montgomery.circom , mux3.circom and babyjub.circom from the circom library.","title":"Include"},{"location":"circom-language/include/#include","text":"Templates, like other code, can be found in other files like in libraries. In order to use code in other files, we have to include them in our program by using the keyword include, with the corresponding name of the file (.circom extension is the default). include \"montgomery.circom\"; include \"mux3.circom\"; include \"babyjub.circom\"; This piece of code includes the files montgomery.circom , mux3.circom and babyjub.circom from the circom library.","title":"Include"},{"location":"circom-language/pragma/","text":"Pragma Version pragma All files with .circom extension should start with a first pragma instruction specifying the compiler version, like this: pragma circom xx.yy.zz; This is to ensure that the circuit is compatible with the compiler version indicated after the pragma instruction. Otherwise, the compiler throws a warning. If a file does not contain this instruction, it is assumed that the code is compatible with the latest compiler's version and a warning is thrown. Custom templates pragma Since circom 2.0.6, the language allows the definition of custom templates (see this for more information). This pragma allows the circom programmer to easily tell if it's using custom templates: if any file declaring a custom template or including a file declaring any custom template doesn't use this pragma , the compiler will produce an error. Moreover, it will inform the programmer about which files should include this pragma. To use it simply add the following instruction at the beginning (and after the version pragma ) of the .circom files that needs it: pragma custom_templates;","title":"Pragma"},{"location":"circom-language/pragma/#pragma","text":"","title":"Pragma"},{"location":"circom-language/pragma/#version-pragma","text":"All files with .circom extension should start with a first pragma instruction specifying the compiler version, like this: pragma circom xx.yy.zz; This is to ensure that the circuit is compatible with the compiler version indicated after the pragma instruction. Otherwise, the compiler throws a warning. If a file does not contain this instruction, it is assumed that the code is compatible with the latest compiler's version and a warning is thrown.","title":"Version pragma"},{"location":"circom-language/pragma/#custom-templates-pragma","text":"Since circom 2.0.6, the language allows the definition of custom templates (see this for more information). This pragma allows the circom programmer to easily tell if it's using custom templates: if any file declaring a custom template or including a file declaring any custom template doesn't use this pragma , the compiler will produce an error. Moreover, it will inform the programmer about which files should include this pragma. To use it simply add the following instruction at the beginning (and after the version pragma ) of the .circom files that needs it: pragma custom_templates;","title":"Custom templates pragma"},{"location":"circom-language/reserved-keywords/","text":"Reserved Keywords The list of reserved keywords is the following: signal: Declare a new signal. input: Declare the signal as input. output: Declare the signal as output. public: Declare the signal as public. template: Define a new circuit. component: Instantiate a template. var: Declare a new integer variable. function: Define a new function. return: Return from function. if: Branch based on the result of a conditional expression. else: Fallback for if control flow construct. for: Loop conditionally based on the result of an expression. while: Loop conditionally based on the result of an expression. do: Loop conditionally based on the result of an expression. log: Print the result of the evaluation. assert: Check the condition at construction time. include: Include code of the indicated file. pragma circom : Instruction to check the compiler version. pragma custom_templates : Instruction to indicate the usage of custom templates.","title":"Reserved-keywords"},{"location":"circom-language/reserved-keywords/#reserved-keywords","text":"The list of reserved keywords is the following: signal: Declare a new signal. input: Declare the signal as input. output: Declare the signal as output. public: Declare the signal as public. template: Define a new circuit. component: Instantiate a template. var: Declare a new integer variable. function: Define a new function. return: Return from function. if: Branch based on the result of a conditional expression. else: Fallback for if control flow construct. for: Loop conditionally based on the result of an expression. while: Loop conditionally based on the result of an expression. do: Loop conditionally based on the result of an expression. log: Print the result of the evaluation. assert: Check the condition at construction time. include: Include code of the indicated file. pragma circom : Instruction to check the compiler version. pragma custom_templates : Instruction to indicate the usage of custom templates.","title":"Reserved Keywords"},{"location":"circom-language/scoping/","text":"Scoping Circom has static scoping like C and Rust. However, we have that signals and components must have global scoping and hence they should be defined at the top-level block of the template that defines them. pragma circom 2.0.0; template Multiplier2 (N) { //Declaration of signals. signal input in; signal output out; //Statements. out <== in; signal input x; if(N > 0){ signal output out2; out2 <== x; } } component main = Multiplier2(5); Signal out2 must be declared at the top-level block. The next compilation error is produced: \" out2 is outside the initial scope\" . Regarding visibility, a signal x of component c is also visible in the template t that has declared c, using the notation c.x. No access to signals of nested sub-components is allowed. For instance, if c is built using another component d, the signals of d cannot be accessed from t. This can be seen in the next code: pragma circom 2.0.0; template d(){ signal output x; x <== 1; } template c(){ signal output out2; out2 <== 2; component comp2 = d(); } template t(){ signal out; component c3 = c(); out <== c3.comp2.x; } component main = t(); This code produces a compilation error since we cannot access comp2 of component c3 . A var can be defined at any block and its visibility is reduced to the block like in C or Rust.","title":"Scoping"},{"location":"circom-language/scoping/#scoping","text":"Circom has static scoping like C and Rust. However, we have that signals and components must have global scoping and hence they should be defined at the top-level block of the template that defines them. pragma circom 2.0.0; template Multiplier2 (N) { //Declaration of signals. signal input in; signal output out; //Statements. out <== in; signal input x; if(N > 0){ signal output out2; out2 <== x; } } component main = Multiplier2(5); Signal out2 must be declared at the top-level block. The next compilation error is produced: \" out2 is outside the initial scope\" . Regarding visibility, a signal x of component c is also visible in the template t that has declared c, using the notation c.x. No access to signals of nested sub-components is allowed. For instance, if c is built using another component d, the signals of d cannot be accessed from t. This can be seen in the next code: pragma circom 2.0.0; template d(){ signal output x; x <== 1; } template c(){ signal output out2; out2 <== 2; component comp2 = d(); } template t(){ signal out; component c3 = c(); out <== c3.comp2.x; } component main = t(); This code produces a compilation error since we cannot access comp2 of component c3 . A var can be defined at any block and its visibility is reduced to the block like in C or Rust.","title":"Scoping"},{"location":"circom-language/signals/","text":"Signals & Variables The arithmetic circuits built using circom operate on signals, which contain field elements in Z/pZ. Signals can be named with an identifier or can be stored in arrays and declared using the keyword signal. Signals can be defined as input or output, and are considered intermediate signals otherwise. signal input in; signal output out[N]; signal inter; This small example declares an input signal with identifier in , an N-dimension array of output signals with identifier out and an intermediate signal with identifier inter . Signals are always considered private. The programmer can distinguish between public and private signals only when defining the main component, by providing the list of public input signals. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); Since circom 2.0.4, it is also allowed the initialization of intermediate and outputs signals right after their declaration. Then, the previous example can be rewritten as follows: pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); This example declares input signals in1 and in2 of the main component as public signals. In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public. Thus, from the programmer's point of view, only public input and output signals are visible from outside the circuit, and hence no intermediate signal can be accessed. pragma circom 2.0.0; template A(){ signal input in; signal outA; //We do not declare it as output. outA <== in; } template B(){ //Declaration of signals signal output out; component comp = A(); out <== comp.outA; } component main = B(); This code produces a compilation error since signal outA is not declared as an output signal, then it cannot be accessed and assigned to signal out . Signals are immutable, which means that once they have a value assigned, this value cannot be changed any more. Hence, if a signal is assigned twice, a compilation error is generated. This can be seen in the next example where signal out is assigned twice, producing a compilation error. pragma circom 2.0.0; template A(){ signal input in; signal output outA; outA <== in; } template B(){ //Declaration of signals signal output out; out <== 0; component comp = A(); comp.in <== 0; out <== comp.outA; } component main = B(); At compilation time, the content of a signal is always considered unknown (see Unknowns ), even if a constant is already assigned to them. The reason for that is to provide a precise \\(decidable\\) definition of which constructions are allowed and which are not, without depending on the power of the compiler to detect whether a signal has always a constant value or not. pragma circom 2.0.0; template A(){ signal input in; signal output outA; var i = 0; var out; while (i < in){ out++; i++; } outA <== out; } template B(){ component a = A(); a.in <== 3; } component main = B(); This example produces a compilation error since value of signal outA depends on the value of signal in , even though, such a value is the constant 3. Signals can only be assigned using the operations <-- or <== (see Basic operators ) with the signal on the left hand side and and --> or ==> (see Basic operators ) with the signal on the right hand side. The safe options are <== and ==> , since they assign values and also generate constraints at the same time. Using <-- and --> is, in general, dangerous and should only be used when the assigned expression cannot be included in a constraint, like in the following example. out[k] <-- (in >> k) & 1;","title":"\u30b7\u30b0\u30ca\u30eb"},{"location":"circom-language/signals/#signals-variables","text":"The arithmetic circuits built using circom operate on signals, which contain field elements in Z/pZ. Signals can be named with an identifier or can be stored in arrays and declared using the keyword signal. Signals can be defined as input or output, and are considered intermediate signals otherwise. signal input in; signal output out[N]; signal inter; This small example declares an input signal with identifier in , an N-dimension array of output signals with identifier out and an intermediate signal with identifier inter . Signals are always considered private. The programmer can distinguish between public and private signals only when defining the main component, by providing the list of public input signals. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); Since circom 2.0.4, it is also allowed the initialization of intermediate and outputs signals right after their declaration. Then, the previous example can be rewritten as follows: pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out <== in1 * in2; } component main {public [in1,in2]} = Multiplier2(); This example declares input signals in1 and in2 of the main component as public signals. In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public. Thus, from the programmer's point of view, only public input and output signals are visible from outside the circuit, and hence no intermediate signal can be accessed. pragma circom 2.0.0; template A(){ signal input in; signal outA; //We do not declare it as output. outA <== in; } template B(){ //Declaration of signals signal output out; component comp = A(); out <== comp.outA; } component main = B(); This code produces a compilation error since signal outA is not declared as an output signal, then it cannot be accessed and assigned to signal out . Signals are immutable, which means that once they have a value assigned, this value cannot be changed any more. Hence, if a signal is assigned twice, a compilation error is generated. This can be seen in the next example where signal out is assigned twice, producing a compilation error. pragma circom 2.0.0; template A(){ signal input in; signal output outA; outA <== in; } template B(){ //Declaration of signals signal output out; out <== 0; component comp = A(); comp.in <== 0; out <== comp.outA; } component main = B(); At compilation time, the content of a signal is always considered unknown (see Unknowns ), even if a constant is already assigned to them. The reason for that is to provide a precise \\(decidable\\) definition of which constructions are allowed and which are not, without depending on the power of the compiler to detect whether a signal has always a constant value or not. pragma circom 2.0.0; template A(){ signal input in; signal output outA; var i = 0; var out; while (i < in){ out++; i++; } outA <== out; } template B(){ component a = A(); a.in <== 3; } component main = B(); This example produces a compilation error since value of signal outA depends on the value of signal in , even though, such a value is the constant 3. Signals can only be assigned using the operations <-- or <== (see Basic operators ) with the signal on the left hand side and and --> or ==> (see Basic operators ) with the signal on the right hand side. The safe options are <== and ==> , since they assign values and also generate constraints at the same time. Using <-- and --> is, in general, dangerous and should only be used when the assigned expression cannot be included in a constraint, like in the following example. out[k] <-- (in >> k) & 1;","title":"Signals &amp; Variables"},{"location":"circom-language/tags/","text":"Signal Tags circom 2.1.0 introduces a new feature called signal tags . Tags can be defined during the declaration of any signal in a template. The tag list is indicated between brackets right before the signal name. signal (input/output) {tag_1,...,tag_n} signalname; Let us see a first well-known example in the circomlib, where the tag is declared in an input signal: template Bits2Num(n) { signal input {binary} in[n]; signal output out; var lc1=0; var e2 = 1; for (var i = 0; i<n; i++) { lc1 += in[i] * e2; e2 = e2 + e2; } lc1 ==> out; } template A(){ ... component b = Bits2Num(10); b.in <== a; ... } The input array in is declared with the tag binary . This tag means that each signal in the array is always expected to be 0 or 1 , in order to compute the corresponding number correctly. Then, whenever the previous template is instantiated, the compiler checks if the array a assigned to the input array has the tag binary, since in has the tag binary in its declaration. If it does not, an error is reported. Notice that the compiler also checks if both arrays have the same size. It is important to highlight that the compiler does never make any check about the validity of the tags. It is the programmer's responsability to include the constraints and executable code to guarantee that the inteded meaning of each signal is always true. Let us consider another well-known template that the programmer can use to guarantee that the output signal is always binary. template IsZero() { signal input in; signal output {binary} out; signal inv; inv <-- in!=0 ? 1/in : 0; out <== -in*inv +1; in*out === 0; } To the light of this example, when using tags in intermediate or output signals, the programmer must use components like the previous one or explicitly include the constraints to guarantee the validity of the tags. Tags with value Notice that in the previous template Bits2Num , we can add more information about the output signal out : the maximum number of bits needed to represent it is n . To express this fact is necessary that tags can have a value. The value of the tag can be accessed using the notation . at any moment as a part of an arithmetic expression. However, if the tag has not been previously initialized, then the compiler reports an error. The value of the tag can be also modified using the notation . , as long as the corresponding signal has not received any value. Valued tags behave like parameters which means that they can only be assigned to values known at compilation time. Let us modify the previous example to include this tag in the template. template Bits2Num(n) { signal input {binary} in[n]; signal output {maxbit} out; var lc1=0; var e2 = 1; for (var i = 0; i<n; i++) { lc1 += in[i] * e2; e2 = e2 + e2; } out.maxbit = n; lc1 ==> out; } On the other hand, the next code is erroneous since the tag value is modified after the output receives its value. template Bits2Num(n) { ... lc1 ==> out; out.maxbit = n; } Tags in signal arrays Every signal in an array has exactly the same tag value. Then, the tag is accessed directly from the array name instead of accessing from a particular signal in the array. Similarly to the previous erroneous example: if a particular position of the array is modified, then the tag value of the whole array cannot be modified at all.","title":"Tags"},{"location":"circom-language/tags/#signal-tags","text":"circom 2.1.0 introduces a new feature called signal tags . Tags can be defined during the declaration of any signal in a template. The tag list is indicated between brackets right before the signal name. signal (input/output) {tag_1,...,tag_n} signalname; Let us see a first well-known example in the circomlib, where the tag is declared in an input signal: template Bits2Num(n) { signal input {binary} in[n]; signal output out; var lc1=0; var e2 = 1; for (var i = 0; i<n; i++) { lc1 += in[i] * e2; e2 = e2 + e2; } lc1 ==> out; } template A(){ ... component b = Bits2Num(10); b.in <== a; ... } The input array in is declared with the tag binary . This tag means that each signal in the array is always expected to be 0 or 1 , in order to compute the corresponding number correctly. Then, whenever the previous template is instantiated, the compiler checks if the array a assigned to the input array has the tag binary, since in has the tag binary in its declaration. If it does not, an error is reported. Notice that the compiler also checks if both arrays have the same size. It is important to highlight that the compiler does never make any check about the validity of the tags. It is the programmer's responsability to include the constraints and executable code to guarantee that the inteded meaning of each signal is always true. Let us consider another well-known template that the programmer can use to guarantee that the output signal is always binary. template IsZero() { signal input in; signal output {binary} out; signal inv; inv <-- in!=0 ? 1/in : 0; out <== -in*inv +1; in*out === 0; } To the light of this example, when using tags in intermediate or output signals, the programmer must use components like the previous one or explicitly include the constraints to guarantee the validity of the tags.","title":"Signal Tags"},{"location":"circom-language/tags/#tags-with-value","text":"Notice that in the previous template Bits2Num , we can add more information about the output signal out : the maximum number of bits needed to represent it is n . To express this fact is necessary that tags can have a value. The value of the tag can be accessed using the notation . at any moment as a part of an arithmetic expression. However, if the tag has not been previously initialized, then the compiler reports an error. The value of the tag can be also modified using the notation . , as long as the corresponding signal has not received any value. Valued tags behave like parameters which means that they can only be assigned to values known at compilation time. Let us modify the previous example to include this tag in the template. template Bits2Num(n) { signal input {binary} in[n]; signal output {maxbit} out; var lc1=0; var e2 = 1; for (var i = 0; i<n; i++) { lc1 += in[i] * e2; e2 = e2 + e2; } out.maxbit = n; lc1 ==> out; } On the other hand, the next code is erroneous since the tag value is modified after the output receives its value. template Bits2Num(n) { ... lc1 ==> out; out.maxbit = n; }","title":"Tags with value"},{"location":"circom-language/tags/#tags-in-signal-arrays","text":"Every signal in an array has exactly the same tag value. Then, the tag is accessed directly from the array name instead of accessing from a particular signal in the array. Similarly to the previous erroneous example: if a particular position of the array is modified, then the tag value of the whole array cannot be modified at all.","title":"Tags in signal arrays"},{"location":"circom-language/templates-and-components/","text":"Templates & Components Templates The mechanism to create generic circuits in Circom is the so-called templates. They are normally parametric on some values that must be instantiated when the template is used. The instantiation of a template is a new circuit object, which can be used to compose other circuits, so as part of larger circuits. Since templates define circuits by instantiation, they have their own signals \\(input, output, etc\\) . template tempid ( param_1, ... , param_n ) { signal input a; signal output b; ..... } Templates cannot include local functions or template definitions. Assigning a value to an input signal inside the same template where it has been defined also generates the error \"Exception caused by invalid assignment\" as can be seen in the next example. pragma circom 2.0.0; template wrong (N) { signal input a; signal output b; a <== N; } component main = wrong(1); The instantiation of a template is made using the keyword component and by providing the necessary parameters. component c = tempid(v1,...,vn); The values of the parameters should be known constants at compile time. The next code produces this compilation error message: \"Every component instantiation must be resolved during the constraint generation phase\". pragma circom 2.0.0; template A(N1,N2){ signal input in; signal output out; out <== N1 * in * N2; } template wrong (N) { signal input a; signal output b; component c = A(a,N); } component main {public [a]} = wrong(1); Regarding the signals defined in the template that will be part of the component, the following compiler messages will be generated if we use the option --inspect to compile the code: If a signal is not used in any constraint, a warning message will be generated. Moreover, if it is an input signal x then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"In template \"A \\(1\\) \". Unconstrained signal. \"in\" = Maybe use: in*0 === 0\" If an intermediary signal is used only in one constraint, a hint message will be generated. pragma circom 2.0.0; template A(N){ signal input in; signal inter; inter <== 1; signal output out; out <== in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"_In template \"A \\(1\\) \". One constraint intermediate: \"inter\" = Maybe use: inter*0 === 0\". If there is no output signal a warning message will be generated. pragma circom 2.0.0; template A(N){ signal input in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"There is no output signal.\" . Components A component defines an arithmetic circuit and, as such, it receives N input signals and produces M output signals and K intermediate signals. Additionally, it can produce a set of constraints. In order to access the input or output signals of a component, we will use dot notation . No other signals are visible outside the component. c.a <== y*z-1; var x; x = c.b; The component instantiation will not be triggered until all its input signals are assigned to concrete values. Therefore the instantiation might be delayed and hence the component creation instruction does not imply the execution of the component object, but the creation of the instantiation process that will be completed when all the inputs are set. The output signals of a component can only be used when all inputs are set, otherwise a compiler error is generated. For instance, the following piece of code would result in an error: pragma circom 2.0.0; template Internal() { signal input in[2]; signal output out; out <== in[0]*in[1]; } template Main() { signal input in[2]; signal output out; component c = Internal (); c.in[0] <== in[0]; c.out ==> out; // c.in[1] is not assigned yet c.in[1] <== in[1]; // this line should be placed before calling c.out } component main = Main(); Components are immutable (like signals). A component can be declared first and initialized in a second step. If there are several initialization instructions (in different execution paths) they all need to be instantiations of the same template (maybe with different values for the parameters). template A(N){ signal input in; signal output out; out <== in; } template C(N){ signal output out; out <== N; } template B(N){ signal output out; component a; if(N > 0){ a = A(N); } else{ a = A(0); } } component main = B(1); If the instruction a = A(0); is replaced with a = C(0) , the compilation fails and the next error message is shown: \"Assignee and assigned types do not match\" . We can define arrays of components following the same restrictions on the size given before. Moreover, initialization in the definition of arrays of components is not allowed, and instantiation can only be made component by component, accessing the positions of the array. All components in the array have to be instances of the same template as it can be seen in the next example. template MultiAND(n) { signal input in[n]; signal output out; component and; component ands[2]; var i; if (n==1) { out <== in[0]; } else if (n==2) { and = AND(); and.a <== in[0]; and.b <== in[1]; out <== and.out; } else { and = AND(); var n1 = n\\2; var n2 = n-n\\2; ands[0] = MultiAND(n1); ands[1] = MultiAND(n2); for (i=0; i<n1; i++) ands[0].in[i] <== in[i]; for (i=0; i<n2; i++) ands[1].in[i] <== in[n1+i]; and.a <== ands[0].out; and.b <== ands[1].out; out <== and.out; } } When components are independent (the inputs do not depend on each others\u2019 outputs), the computation of these parts can be done in parallel using the tag parallel , like shown in the next line. template parallel NameTemplate(...){...} If this tag is used, the resulting C++ file will contain the parallelized code to compute the witness. Parallelization becomes particularly relevant when dealing with large circuits. Notice that the previous parallelism is declared at template level. Sometimes, it can be useful declare the parallelism for each component. Since version 2.0.8, the tag parallel can be also used at component level, with the parallel tag indicated right before the call to the template. component comp = parallel NameTemplate(...){...} A real example of use case is the following piece of code from the rollup code: component rollupTx[nTx]; for (i = 0; i < nTx; i++) { rollupTx[i] = parallel RollupTx(nLevels, maxFeeTx); } It is important to highlight again that this parallelism can only be exploited in C++ witness generator. Custom templates Since version 2.0.6, the language allows the definition of a new type of templates, custom templates. This new construction works similarly to standard templates: they are declared analogously, just adding the keyword custom in its declaration after template ; and are instantiated in the exact same way. That is, a custom template Example is defined and then instantiated as follows: pragma circom 2.0.6; // note that custom templates are only allowed since version 2.0.6 pragma custom_templates; template custom Example() { // custom template's code } template UsingExample() { component example = Example(); // instantiation of the custom template } However, the way in which their computation is encoded is different from the one for standard templates. Instead of producing r1cs constraints, the usage of each defined custom template will be treated in a later stage by snarkjs to generate and validate the zk proof, in this case using the PLONK scheme (and using the custom template's definitions as PLONK's custom gates, see here how). Information about the definition and usages of custom templates will be exported in the .r1cs file (see here sections 4 and 5). This means that custom templates cannot introduce any constraint inside their body, nor declare any subcomponent.","title":"Templates & Components"},{"location":"circom-language/templates-and-components/#templates-components","text":"","title":"Templates &amp; Components"},{"location":"circom-language/templates-and-components/#templates","text":"The mechanism to create generic circuits in Circom is the so-called templates. They are normally parametric on some values that must be instantiated when the template is used. The instantiation of a template is a new circuit object, which can be used to compose other circuits, so as part of larger circuits. Since templates define circuits by instantiation, they have their own signals \\(input, output, etc\\) . template tempid ( param_1, ... , param_n ) { signal input a; signal output b; ..... } Templates cannot include local functions or template definitions. Assigning a value to an input signal inside the same template where it has been defined also generates the error \"Exception caused by invalid assignment\" as can be seen in the next example. pragma circom 2.0.0; template wrong (N) { signal input a; signal output b; a <== N; } component main = wrong(1); The instantiation of a template is made using the keyword component and by providing the necessary parameters. component c = tempid(v1,...,vn); The values of the parameters should be known constants at compile time. The next code produces this compilation error message: \"Every component instantiation must be resolved during the constraint generation phase\". pragma circom 2.0.0; template A(N1,N2){ signal input in; signal output out; out <== N1 * in * N2; } template wrong (N) { signal input a; signal output b; component c = A(a,N); } component main {public [a]} = wrong(1); Regarding the signals defined in the template that will be part of the component, the following compiler messages will be generated if we use the option --inspect to compile the code: If a signal is not used in any constraint, a warning message will be generated. Moreover, if it is an input signal x then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"In template \"A \\(1\\) \". Unconstrained signal. \"in\" = Maybe use: in*0 === 0\" If an intermediary signal is used only in one constraint, a hint message will be generated. pragma circom 2.0.0; template A(N){ signal input in; signal inter; inter <== 1; signal output out; out <== in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"_In template \"A \\(1\\) \". One constraint intermediate: \"inter\" = Maybe use: inter*0 === 0\". If there is no output signal a warning message will be generated. pragma circom 2.0.0; template A(N){ signal input in; } component main {public [in]} = A(1); During the compilation of this code, we obtain the next warning message: \"There is no output signal.\" .","title":"Templates"},{"location":"circom-language/templates-and-components/#components","text":"A component defines an arithmetic circuit and, as such, it receives N input signals and produces M output signals and K intermediate signals. Additionally, it can produce a set of constraints. In order to access the input or output signals of a component, we will use dot notation . No other signals are visible outside the component. c.a <== y*z-1; var x; x = c.b; The component instantiation will not be triggered until all its input signals are assigned to concrete values. Therefore the instantiation might be delayed and hence the component creation instruction does not imply the execution of the component object, but the creation of the instantiation process that will be completed when all the inputs are set. The output signals of a component can only be used when all inputs are set, otherwise a compiler error is generated. For instance, the following piece of code would result in an error: pragma circom 2.0.0; template Internal() { signal input in[2]; signal output out; out <== in[0]*in[1]; } template Main() { signal input in[2]; signal output out; component c = Internal (); c.in[0] <== in[0]; c.out ==> out; // c.in[1] is not assigned yet c.in[1] <== in[1]; // this line should be placed before calling c.out } component main = Main(); Components are immutable (like signals). A component can be declared first and initialized in a second step. If there are several initialization instructions (in different execution paths) they all need to be instantiations of the same template (maybe with different values for the parameters). template A(N){ signal input in; signal output out; out <== in; } template C(N){ signal output out; out <== N; } template B(N){ signal output out; component a; if(N > 0){ a = A(N); } else{ a = A(0); } } component main = B(1); If the instruction a = A(0); is replaced with a = C(0) , the compilation fails and the next error message is shown: \"Assignee and assigned types do not match\" . We can define arrays of components following the same restrictions on the size given before. Moreover, initialization in the definition of arrays of components is not allowed, and instantiation can only be made component by component, accessing the positions of the array. All components in the array have to be instances of the same template as it can be seen in the next example. template MultiAND(n) { signal input in[n]; signal output out; component and; component ands[2]; var i; if (n==1) { out <== in[0]; } else if (n==2) { and = AND(); and.a <== in[0]; and.b <== in[1]; out <== and.out; } else { and = AND(); var n1 = n\\2; var n2 = n-n\\2; ands[0] = MultiAND(n1); ands[1] = MultiAND(n2); for (i=0; i<n1; i++) ands[0].in[i] <== in[i]; for (i=0; i<n2; i++) ands[1].in[i] <== in[n1+i]; and.a <== ands[0].out; and.b <== ands[1].out; out <== and.out; } } When components are independent (the inputs do not depend on each others\u2019 outputs), the computation of these parts can be done in parallel using the tag parallel , like shown in the next line. template parallel NameTemplate(...){...} If this tag is used, the resulting C++ file will contain the parallelized code to compute the witness. Parallelization becomes particularly relevant when dealing with large circuits. Notice that the previous parallelism is declared at template level. Sometimes, it can be useful declare the parallelism for each component. Since version 2.0.8, the tag parallel can be also used at component level, with the parallel tag indicated right before the call to the template. component comp = parallel NameTemplate(...){...} A real example of use case is the following piece of code from the rollup code: component rollupTx[nTx]; for (i = 0; i < nTx; i++) { rollupTx[i] = parallel RollupTx(nLevels, maxFeeTx); } It is important to highlight again that this parallelism can only be exploited in C++ witness generator.","title":"Components"},{"location":"circom-language/templates-and-components/#custom-templates","text":"Since version 2.0.6, the language allows the definition of a new type of templates, custom templates. This new construction works similarly to standard templates: they are declared analogously, just adding the keyword custom in its declaration after template ; and are instantiated in the exact same way. That is, a custom template Example is defined and then instantiated as follows: pragma circom 2.0.6; // note that custom templates are only allowed since version 2.0.6 pragma custom_templates; template custom Example() { // custom template's code } template UsingExample() { component example = Example(); // instantiation of the custom template } However, the way in which their computation is encoded is different from the one for standard templates. Instead of producing r1cs constraints, the usage of each defined custom template will be treated in a later stage by snarkjs to generate and validate the zk proof, in this case using the PLONK scheme (and using the custom template's definitions as PLONK's custom gates, see here how). Information about the definition and usages of custom templates will be exported in the .r1cs file (see here sections 4 and 5). This means that custom templates cannot introduce any constraint inside their body, nor declare any subcomponent.","title":"Custom templates"},{"location":"circom-language/the-main-component/","text":"The Main Component In order to start the execution, an initial component has to be given. By default, the name of this component is \u201cmain\u201d, and hence the component main needs to be instantiated with some template. This is a special initial component needed to create a circuit and it defines the global input and output signals of a circuit. For this reason, compared to the other components, it has a special attribute: the list of public input signals. The syntax of the creation of the main component is: component main {public [signal_list]} = tempid(v1,...,vn); where {public [signal_list]} is optional. Any input signal of the template that is not included in the list is considered private. pragma circom 2.0.0; template A(){ signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1]}= A(); In this example, we have two input signals in1 and in2 . Let us notice that in1 has been declared as a public signal for the circuit, whereas in2 is considered a private signal since it does not appear in the list. Finally, output signals are always considered public signals. Only one main component can be defined, not only in the file being compiled but also in any other circom file included in the program. Otherwise, the compilation fails and the next message is shown: \"Multiple main components in the project structure\"","title":"The main Component"},{"location":"circom-language/the-main-component/#the-main-component","text":"In order to start the execution, an initial component has to be given. By default, the name of this component is \u201cmain\u201d, and hence the component main needs to be instantiated with some template. This is a special initial component needed to create a circuit and it defines the global input and output signals of a circuit. For this reason, compared to the other components, it has a special attribute: the list of public input signals. The syntax of the creation of the main component is: component main {public [signal_list]} = tempid(v1,...,vn); where {public [signal_list]} is optional. Any input signal of the template that is not included in the list is considered private. pragma circom 2.0.0; template A(){ signal input in1; signal input in2; signal output out; out <== in1 * in2; } component main {public [in1]}= A(); In this example, we have two input signals in1 and in2 . Let us notice that in1 has been declared as a public signal for the circuit, whereas in2 is considered a private signal since it does not appear in the list. Finally, output signals are always considered public signals. Only one main component can be defined, not only in the file being compiled but also in any other circom file included in the program. Otherwise, the compilation fails and the next message is shown: \"Multiple main components in the project structure\"","title":"The Main Component"},{"location":"circom-language/variables-and-mutability/","text":"Variables & Mutability Variables are identifiers that hold non-signal data and are mutable. Variables are declared using the keyword var as in: var x; They hold either numerical values of the field or arithmetic expressions when they are used to build constraints (see Constraint Generation ). They can be named using a variable identifier or can be stored in arrays. Variable assignment is made using the equal symbol = . Declarations may also include an initialization, as in the following examples: var x; x = 234556; var y = 0; var z[3] = [1,2,3]; An assignment is a statement and does not return any value, hence it cannot be part of an expression, which avoids misleading uses of = . Any use of = inside an expression will lead to a compilation error. The two examples below would result in compilation errors: a = (b = 3) + 2; var x; if (x = 3) { var y = 0; }","title":"Variables & Mutability"},{"location":"circom-language/variables-and-mutability/#variables-mutability","text":"Variables are identifiers that hold non-signal data and are mutable. Variables are declared using the keyword var as in: var x; They hold either numerical values of the field or arithmetic expressions when they are used to build constraints (see Constraint Generation ). They can be named using a variable identifier or can be stored in arrays. Variable assignment is made using the equal symbol = . Declarations may also include an initialization, as in the following examples: var x; x = 234556; var y = 0; var z[3] = [1,2,3]; An assignment is a statement and does not return any value, hence it cannot be part of an expression, which avoids misleading uses of = . Any use of = inside an expression will lead to a compilation error. The two examples below would result in compilation errors: a = (b = 3) + 2; var x; if (x = 3) { var y = 0; }","title":"Variables &amp; Mutability"},{"location":"circom-language/circom-insight/circom-library/","text":"circom Library \ud83d\udc49 CircomLib \ud83d\udc48","title":"Circom Library"},{"location":"circom-language/circom-insight/circom-library/#circom-library","text":"","title":"circom Library"},{"location":"circom-language/circom-insight/circom-library/#circomlib","text":"","title":"\ud83d\udc49 CircomLib \ud83d\udc48"},{"location":"circom-language/circom-insight/circom-phases/","text":"circom Compiler circom has two compilation phases: The construction phase, where the constraints are generated. The code generation phase, where the code to compute the witness is generated. If an error is produced in any of these two phases, circom will finish with an error code greater than 0. Otherwise, if the compiler finish successfully, it finishes returning 0.","title":"Compiler Phases"},{"location":"circom-language/circom-insight/circom-phases/#circom-compiler","text":"circom has two compilation phases: The construction phase, where the constraints are generated. The code generation phase, where the code to compute the witness is generated. If an error is produced in any of these two phases, circom will finish with an error code greater than 0. Otherwise, if the compiler finish successfully, it finishes returning 0.","title":"circom Compiler"},{"location":"circom-language/circom-insight/compiler-messages/","text":"Compiler Messages The compiler messages are basically of three kinds: hints, warnings and errors. A hint This message means that it is allowed but uncommon, and hence it is better to check if it was done on purpose. A warning This message means that it is allowed but should not happen in general. For instance, if a signal is not used in any constraint, a warning message will be generated (when compiling the program with the --inspect option). Moreover, if it is an input signal x, then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1); An error This message means that it is not allowed and the compilation of the program fails. For instance, one of the most common errors we can make when starting to program in circom is trying to assign a value to a signal using = . pragma circom 2.0.0; template A(){ signal in; in = 1; } component main = A(); The compilation fails and the next error is received: \"Assignee and assigned types do not match operator.\"","title":"Compiler Messages"},{"location":"circom-language/circom-insight/compiler-messages/#compiler-messages","text":"The compiler messages are basically of three kinds: hints, warnings and errors.","title":"Compiler Messages"},{"location":"circom-language/circom-insight/compiler-messages/#a-hint","text":"This message means that it is allowed but uncommon, and hence it is better to check if it was done on purpose.","title":"A hint"},{"location":"circom-language/circom-insight/compiler-messages/#a-warning","text":"This message means that it is allowed but should not happen in general. For instance, if a signal is not used in any constraint, a warning message will be generated (when compiling the program with the --inspect option). Moreover, if it is an input signal x, then the compiler would suggest adding a constraint of the form x * 0 === 0; pragma circom 2.0.0; template A(N){ signal input in; signal intermediate; signal output out; intermediate <== 1; out <== intermediate; } component main {public [in]} = A(1);","title":"A warning"},{"location":"circom-language/circom-insight/compiler-messages/#an-error","text":"This message means that it is not allowed and the compilation of the program fails. For instance, one of the most common errors we can make when starting to program in circom is trying to assign a value to a signal using = . pragma circom 2.0.0; template A(){ signal in; in = 1; } component main = A(); The compilation fails and the next error is received: \"Assignee and assigned types do not match operator.\"","title":"An error"},{"location":"circom-language/circom-insight/unknowns/","text":"Unknowns As expressions accepted during constraint generation can at most be quadratic only, certain checks and constraints are imposed on the use of unknown values at compile. In circom, constant values and template parameters are always considered known, while signals are always considered unknown. Expressions depending only on knowns are considered knowns, while those depending on unknowns are considered unknowns. pragma circom 2.0.0; template A(n1, n2){ // known signal input in1; // unknown signal input in2; // unknown var x = 0; // known var y = n1; // known var z = in1; // unknown } component main = A(1, 2); In the code above, the template parameters n1 , n2 and the constant value 0 are considered known. Consequently, the variables x and y are also considered known. Meanwhile, the signals in1 , in2 are considered unknown. Consequently, the variable z is also considered unknown. Array A constraint with an array access must have a known accessing position. pragma circom 2.0.0; template A(n){ signal input in; signal output out; var array[n]; out <== array[in]; // Error: Non-quadratic constraint was detected statically, using unknown index will cause the constraint to be non-quadratic } component main = A(10); In the code above, an array is defined with a known size of value n (as template parameters are always considered known), while a constraint is set to be dependent on the array element at an unknown position in (as signals are always considered unknown). An array must also be defined with a known size. pragma circom 2.0.0; template A(){ signal input in; var array[in]; // Error: The length of every array must known during the constraint generation phase } component main = A(); In the code above, an array is defined with an unknown size of value in (as signals are always considered unknown). Control Flow A constraint generated in a control flow must have a known condition. Take an if-then statement as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; if (in < 0){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== 0; } } component main = A(); In the code above, a constraint is defined in an if-then statement with a comparitive condition involving an unknown value in (as signals are always considered unknown). Similarly, using a for-loop as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; for (var i = 0; i < in; i++){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== i; } } component main = A(); In the code above, a constraint is defined in a for-loop with a counting condition to an unknown value in (as signals are always considered unknown). For additional details, see Control Flow .","title":"Unknowns"},{"location":"circom-language/circom-insight/unknowns/#unknowns","text":"As expressions accepted during constraint generation can at most be quadratic only, certain checks and constraints are imposed on the use of unknown values at compile. In circom, constant values and template parameters are always considered known, while signals are always considered unknown. Expressions depending only on knowns are considered knowns, while those depending on unknowns are considered unknowns. pragma circom 2.0.0; template A(n1, n2){ // known signal input in1; // unknown signal input in2; // unknown var x = 0; // known var y = n1; // known var z = in1; // unknown } component main = A(1, 2); In the code above, the template parameters n1 , n2 and the constant value 0 are considered known. Consequently, the variables x and y are also considered known. Meanwhile, the signals in1 , in2 are considered unknown. Consequently, the variable z is also considered unknown.","title":"Unknowns"},{"location":"circom-language/circom-insight/unknowns/#array","text":"A constraint with an array access must have a known accessing position. pragma circom 2.0.0; template A(n){ signal input in; signal output out; var array[n]; out <== array[in]; // Error: Non-quadratic constraint was detected statically, using unknown index will cause the constraint to be non-quadratic } component main = A(10); In the code above, an array is defined with a known size of value n (as template parameters are always considered known), while a constraint is set to be dependent on the array element at an unknown position in (as signals are always considered unknown). An array must also be defined with a known size. pragma circom 2.0.0; template A(){ signal input in; var array[in]; // Error: The length of every array must known during the constraint generation phase } component main = A(); In the code above, an array is defined with an unknown size of value in (as signals are always considered unknown).","title":"Array"},{"location":"circom-language/circom-insight/unknowns/#control-flow","text":"A constraint generated in a control flow must have a known condition. Take an if-then statement as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; if (in < 0){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== 0; } } component main = A(); In the code above, a constraint is defined in an if-then statement with a comparitive condition involving an unknown value in (as signals are always considered unknown). Similarly, using a for-loop as an example: pragma circom 2.0.0; template A(){ signal input in; signal output out; for (var i = 0; i < in; i++){ // Error: There are constraints depending on the value of the condition and it can be unknown during the constraint generation phase out <== i; } } component main = A(); In the code above, a constraint is defined in a for-loop with a counting condition to an unknown value in (as signals are always considered unknown). For additional details, see Control Flow .","title":"Control Flow"},{"location":"circom-language/code-quality/code-assertion/","text":"Code Assertion assert(bool_expression); This statement introduces conditions to be checked at execution time. If the condition fails, the witness generation is interrupted and the error is reported. template Translate(n) { assert(n<=254); \u2026.. } Recall that, when a constraint is introduced with ===, then an assert is automatically added in the witness generation code.","title":"Code Assertion"},{"location":"circom-language/code-quality/code-assertion/#code-assertion","text":"assert(bool_expression); This statement introduces conditions to be checked at execution time. If the condition fails, the witness generation is interrupted and the error is reported. template Translate(n) { assert(n<=254); \u2026.. } Recall that, when a constraint is introduced with ===, then an assert is automatically added in the witness generation code.","title":"Code Assertion"},{"location":"circom-language/code-quality/debugging-operations/","text":"Debugging Operations In circom there is an operation that can be used while developing circuits to help the programmer debug (note that there are no input/output operations on the standard input/output channels). To this end, the operation log has as parameter a non-conditional expression (i.e., not including the ? ;_ operator). The execution of this instruction prints the result of the evaluation of the expression in the standard error stream. As examples consider: log(135); log(c.b); log(x==y); Since circom 2.0.6, operation log admits a list of non-conditional expressions and also strings written in the standard way. For instance: log(\"The expected result is \",135,\" but the value of a is\",a); Finally, this operations admits an empty list of expressions which is equivalent to print an end-of-line. The next two instructions are equivalent: log(\"\"); log();","title":"Debugging Operations"},{"location":"circom-language/code-quality/debugging-operations/#debugging-operations","text":"In circom there is an operation that can be used while developing circuits to help the programmer debug (note that there are no input/output operations on the standard input/output channels). To this end, the operation log has as parameter a non-conditional expression (i.e., not including the ? ;_ operator). The execution of this instruction prints the result of the evaluation of the expression in the standard error stream. As examples consider: log(135); log(c.b); log(x==y); Since circom 2.0.6, operation log admits a list of non-conditional expressions and also strings written in the standard way. For instance: log(\"The expected result is \",135,\" but the value of a is\",a); Finally, this operations admits an empty list of expressions which is equivalent to print an end-of-line. The next two instructions are equivalent: log(\"\"); log();","title":"Debugging Operations"},{"location":"downloads/downloads/","text":"circom Linux binary circom macOS binary circom Windows binary","title":"\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9"},{"location":"getting-started/compilation-options/","text":"If we use the command circom --help , we can see all the options and flags that we can use during the compilation. USAGE: circom [FLAGS] [OPTIONS] [--] [input] FLAGS: --r1cs Outputs the constraints in r1cs format --sym Outputs witness in sym format --wasm Compiles the circuit to wasm --json Outputs the constraints in json format --wat Compiles the circuit to wat -c, --c Compiles the circuit to c --O0 No simplification is applied --O1 Only applies var to var and var to constant simplification --O2 Full constraint simplification --verbose Shows logs during compilation --inspect Does an additional check over the constraints produced --use_old_simplification_heuristics Applies the old version of the heuristics when performing linear simplification -h, --help Prints help information -V, --version Prints version information OPTIONS: -o, --output <output> Path to the directory where the output will be written [default: .] -p, --prime <prime> To choose the prime number to use to generate the circuit. Receives the name of the curve (bn128, bls12381, goldilocks) [default: bn128] -l <link_libraries>... Adds directory to library search path --O2round <simplification_rounds> Maximum number of rounds of the simplification process ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] In the following, we explain these options. Flags and options related to the compiler's output Flag --r1cs outputs the constraints in R1CS format. Flag --sym outputs the witness in sym format. Flag --wasm produces a WebAssembly program that receives the private and public inputs and generates the circuit witness. Flag -c / --c produces a C++ program that receives the private and public inputs and generates the circuit witness. Flag --wat compiles the circuit to wat. Flag --json outputs the R1CS system in JSON format. Option -o / --output <output> allows to indicate the path to the directory where the output will be written. By default the path is . . Flags and options related to the constraint generation process Flag --verbose shows logs with known values at compilation time during the constraint generation process. Flag --inspect does an additional check over the R1CS system produced. Flag --use_old_simplification_heuristics allows to use an old heuristics of the optimization algorithm. However, it is not recommended since the new heuristics has produced better results in practice. Flags and options related to the R1CS optimization In the following, we explain the different optimizations that we can apply to the final R1CS during the constraint generation phase. Flag --O0 does not apply any kind of simplification. Flag --O1 removes two kinds of simple constraints: a) signal = K , being K is a constant in \\(F_p\\) and b) signal1 = signal2 , which usually appears when linking components inputs and outputs. Flag --O2 applies Gauss elimination to remove as many linear constraints as possible. After applying the substitutions discovered by the algorithm, non-linear constraints may become linear. Thus, the Gauss elimination is applied during several rounds until no more linear constraints are discovered. Option --O2round <simplification_rounds> is similar to --O2 but it limits the maximum number of rounds applied during the optimization. In <simplification_rounds> , user needs to indicate the number of rounds. Only one of these flags/options must be used during the compilation. Other flags and options Option -p, --prime <prime> allows the user indicate which prime must be used during the compilation. Currently, it admits three different primes: bn128, bls12381 and goldilock. If not indicated, the default prime is bn128. Option -l <link_libraries> adds the provided directory in <link_libraries> to the library search path. It is possible to add as much -l <link_libraries> as needed, but only one directory per option. Flag -v / --version prints the version information. Flag -h / --help prints the help information.","title":"Compilation options"},{"location":"getting-started/compilation-options/#flags-and-options-related-to-the-compilers-output","text":"Flag --r1cs outputs the constraints in R1CS format. Flag --sym outputs the witness in sym format. Flag --wasm produces a WebAssembly program that receives the private and public inputs and generates the circuit witness. Flag -c / --c produces a C++ program that receives the private and public inputs and generates the circuit witness. Flag --wat compiles the circuit to wat. Flag --json outputs the R1CS system in JSON format. Option -o / --output <output> allows to indicate the path to the directory where the output will be written. By default the path is . .","title":"Flags and options related to the compiler's output"},{"location":"getting-started/compilation-options/#flags-and-options-related-to-the-constraint-generation-process","text":"Flag --verbose shows logs with known values at compilation time during the constraint generation process. Flag --inspect does an additional check over the R1CS system produced. Flag --use_old_simplification_heuristics allows to use an old heuristics of the optimization algorithm. However, it is not recommended since the new heuristics has produced better results in practice.","title":"Flags and options related to the constraint generation process"},{"location":"getting-started/compilation-options/#flags-and-options-related-to-the-r1cs-optimization","text":"In the following, we explain the different optimizations that we can apply to the final R1CS during the constraint generation phase. Flag --O0 does not apply any kind of simplification. Flag --O1 removes two kinds of simple constraints: a) signal = K , being K is a constant in \\(F_p\\) and b) signal1 = signal2 , which usually appears when linking components inputs and outputs. Flag --O2 applies Gauss elimination to remove as many linear constraints as possible. After applying the substitutions discovered by the algorithm, non-linear constraints may become linear. Thus, the Gauss elimination is applied during several rounds until no more linear constraints are discovered. Option --O2round <simplification_rounds> is similar to --O2 but it limits the maximum number of rounds applied during the optimization. In <simplification_rounds> , user needs to indicate the number of rounds. Only one of these flags/options must be used during the compilation.","title":"Flags and options related to the R1CS optimization"},{"location":"getting-started/compilation-options/#other-flags-and-options","text":"Option -p, --prime <prime> allows the user indicate which prime must be used during the compilation. Currently, it admits three different primes: bn128, bls12381 and goldilock. If not indicated, the default prime is bn128. Option -l <link_libraries> adds the provided directory in <link_libraries> to the library search path. It is possible to add as much -l <link_libraries> as needed, but only one directory per option. Flag -v / --version prints the version information. Flag -h / --help prints the help information.","title":"Other flags and options"},{"location":"getting-started/compiling-circuits/","text":"\u56de\u8def\u306e\u30b3\u30f3\u30d1\u30a4\u30eb \u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5229\u7528\u53ef\u80fd\u306a\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002 circom --help Circom Compiler 2.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] \u521d\u3081\u3066\u306e\u56de\u8def\u306e\u8a18\u8ff0 \u3067 Multiplier2 \u3068\u3044\u3046\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u4f5c\u308a\u307e\u3057\u305f\u3002 \u3057\u304b\u3057\u3001\u5b9f\u969b\u306b\u56de\u8def\u3092\u4f5c\u6210\u3059\u308b\u306b\u306f\u3001\u3053\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 pragma circom 2.0.0; template Multiplier2() { signal input a; signal input b; signal output c; c <== a*b; } component main = Multiplier2(); circom \u3092\u4f7f\u3063\u3066\u7b97\u8853\u56de\u8def\u3092\u66f8\u3044\u305f\u3089\u3001\u305d\u308c\u3092\u62e1\u5f35\u5b50 .circom \u306e\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u56de\u8def\u306f\u81ea\u5206\u3067\u4f5c\u6210\u3057\u3066\u3082\u3088\u3044\u3067\u3059\u3057\u3001\u56de\u8def\u30e9\u30a4\u30d6\u30e9\u30ea circomlib \u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u4f7f\u3063\u3066\u3082\u3088\u3044\u3053\u3068\u3092\u5fd8\u308c\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002 \u3053\u306e\u4f8b\u3067\u306f\u3001 multiplier2.circom \u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 \u3042\u3068\u306f\u56de\u8def\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u3001\u56de\u8def\u3092\u8868\u3059\u7b97\u8853\u65b9\u7a0b\u5f0f\u7cfb\u3092\u5f97\u307e\u3059\u3002\u30b3\u30f3\u30d1\u30a4\u30eb\u306e\u7d50\u679c\u3001\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3092\u8a08\u7b97\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3082\u5f97\u3089\u308c\u307e\u3059\u3002 \u30b3\u30f3\u30d1\u30a4\u30eb\u306f\u6b21\u306e\u30b3\u30de\u30f3\u30c9\u3067\u884c\u3048\u307e\u3059\u3002 circom multiplier2.circom --r1cs --wasm --sym --c \u3053\u308c\u3089\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30013\u7a2e\u985e\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u751f\u6210\u3057\u307e\u3059\u3002 --r1cs : \u56de\u8def\u306e R1CS \u3092\u30d0\u30a4\u30ca\u30ea\u5f62\u5f0f\u3067\u542b\u3080\u30d5\u30a1\u30a4\u30eb multiplier2.r1cs \u3092\u751f\u6210\u3057\u307e\u3059\u3002 --wasm : Wasm \u306e\u30b3\u30fc\u30c9\uff08multiplier2.wasm\uff09\u3068 \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9 \u3092\u751f\u6210\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u305d\u306e\u4ed6\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u542b\u3080\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_js \u3092\u751f\u6210\u3057\u307e\u3059\u3002 --sym : \u6ce8\u91c8\u4ed8\u304d\u30e2\u30fc\u30c9\u3067Constraint System\u306e\u30c7\u30d0\u30c3\u30b0\u3084\u51fa\u529b\u306b\u5fc5\u8981\u306a\u30b7\u30f3\u30dc\u30eb\u30d5\u30a1\u30a4\u30eb multiplier2.sym \u3092\u751f\u6210\u3057\u307e\u3059\u3002 --c : witness\u3092\u751f\u6210\u3059\u308b\u305f\u3081\u306eC\u30b3\u30fc\u30c9\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u306b\u5fc5\u8981\u306a\u3044\u304f\u3064\u304b\u306e\u30d5\u30a1\u30a4\u30eb\uff08multiplier2.cpp\u3001multiplier2.dat\u3001\u307e\u305f\u3001main.cpp\u3084MakeFile\u306a\u3069\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u306b\u5171\u901a\u306e\u30d5\u30a1\u30a4\u30eb\uff09\u3092\u542b\u3080\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_cpp \u3092\u751f\u6210\u3057\u307e\u3059\u3002 \u3053\u308c\u3089\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3059\u308b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u6307\u5b9a\u3059\u308b\u305f\u3081\u306b\u3001\u30aa\u30d7\u30b7\u30e7\u30f3 -o \u3092\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002 \u30d0\u30fc\u30b8\u30e7\u30f32.0.8\u4ee5\u964d\u3067\u306f\u3001\u30aa\u30d7\u30b7\u30e7\u30f3 -l \u3092\u4f7f\u7528\u3057\u3066\u3001\u30c7\u30a3\u30ec\u30af\u30c6\u30a3\u30d6 include \u304c\u793a\u3055\u308c\u305f\u56de\u8def\u3092\u63a2\u3059\u3079\u304d\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u793a\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002","title":"\u56de\u8def\u306e\u30b3\u30f3\u30d1\u30a4\u30eb"},{"location":"getting-started/compiling-circuits/#_1","text":"\u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5229\u7528\u53ef\u80fd\u306a\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u8868\u793a\u3067\u304d\u307e\u3059\u3002 circom --help Circom Compiler 2.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] \u521d\u3081\u3066\u306e\u56de\u8def\u306e\u8a18\u8ff0 \u3067 Multiplier2 \u3068\u3044\u3046\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u4f5c\u308a\u307e\u3057\u305f\u3002 \u3057\u304b\u3057\u3001\u5b9f\u969b\u306b\u56de\u8def\u3092\u4f5c\u6210\u3059\u308b\u306b\u306f\u3001\u3053\u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306b\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 pragma circom 2.0.0; template Multiplier2() { signal input a; signal input b; signal output c; c <== a*b; } component main = Multiplier2(); circom \u3092\u4f7f\u3063\u3066\u7b97\u8853\u56de\u8def\u3092\u66f8\u3044\u305f\u3089\u3001\u305d\u308c\u3092\u62e1\u5f35\u5b50 .circom \u306e\u30d5\u30a1\u30a4\u30eb\u306b\u4fdd\u5b58\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u56de\u8def\u306f\u81ea\u5206\u3067\u4f5c\u6210\u3057\u3066\u3082\u3088\u3044\u3067\u3059\u3057\u3001\u56de\u8def\u30e9\u30a4\u30d6\u30e9\u30ea circomlib \u306e\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3092\u4f7f\u3063\u3066\u3082\u3088\u3044\u3053\u3068\u3092\u5fd8\u308c\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002 \u3053\u306e\u4f8b\u3067\u306f\u3001 multiplier2.circom \u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 \u3042\u3068\u306f\u56de\u8def\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u3001\u56de\u8def\u3092\u8868\u3059\u7b97\u8853\u65b9\u7a0b\u5f0f\u7cfb\u3092\u5f97\u307e\u3059\u3002\u30b3\u30f3\u30d1\u30a4\u30eb\u306e\u7d50\u679c\u3001\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3092\u8a08\u7b97\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u3082\u5f97\u3089\u308c\u307e\u3059\u3002 \u30b3\u30f3\u30d1\u30a4\u30eb\u306f\u6b21\u306e\u30b3\u30de\u30f3\u30c9\u3067\u884c\u3048\u307e\u3059\u3002 circom multiplier2.circom --r1cs --wasm --sym --c \u3053\u308c\u3089\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u3067\u30013\u7a2e\u985e\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u751f\u6210\u3057\u307e\u3059\u3002 --r1cs : \u56de\u8def\u306e R1CS \u3092\u30d0\u30a4\u30ca\u30ea\u5f62\u5f0f\u3067\u542b\u3080\u30d5\u30a1\u30a4\u30eb multiplier2.r1cs \u3092\u751f\u6210\u3057\u307e\u3059\u3002 --wasm : Wasm \u306e\u30b3\u30fc\u30c9\uff08multiplier2.wasm\uff09\u3068 \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9 \u3092\u751f\u6210\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u305d\u306e\u4ed6\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u542b\u3080\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_js \u3092\u751f\u6210\u3057\u307e\u3059\u3002 --sym : \u6ce8\u91c8\u4ed8\u304d\u30e2\u30fc\u30c9\u3067Constraint System\u306e\u30c7\u30d0\u30c3\u30b0\u3084\u51fa\u529b\u306b\u5fc5\u8981\u306a\u30b7\u30f3\u30dc\u30eb\u30d5\u30a1\u30a4\u30eb multiplier2.sym \u3092\u751f\u6210\u3057\u307e\u3059\u3002 --c : witness\u3092\u751f\u6210\u3059\u308b\u305f\u3081\u306eC\u30b3\u30fc\u30c9\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u306b\u5fc5\u8981\u306a\u3044\u304f\u3064\u304b\u306e\u30d5\u30a1\u30a4\u30eb\uff08multiplier2.cpp\u3001multiplier2.dat\u3001\u307e\u305f\u3001main.cpp\u3084MakeFile\u306a\u3069\u306e\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\u306b\u5171\u901a\u306e\u30d5\u30a1\u30a4\u30eb\uff09\u3092\u542b\u3080\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_cpp \u3092\u751f\u6210\u3057\u307e\u3059\u3002 \u3053\u308c\u3089\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3059\u308b\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u6307\u5b9a\u3059\u308b\u305f\u3081\u306b\u3001\u30aa\u30d7\u30b7\u30e7\u30f3 -o \u3092\u4f7f\u7528\u3067\u304d\u307e\u3059\u3002 \u30d0\u30fc\u30b8\u30e7\u30f32.0.8\u4ee5\u964d\u3067\u306f\u3001\u30aa\u30d7\u30b7\u30e7\u30f3 -l \u3092\u4f7f\u7528\u3057\u3066\u3001\u30c7\u30a3\u30ec\u30af\u30c6\u30a3\u30d6 include \u304c\u793a\u3055\u308c\u305f\u56de\u8def\u3092\u63a2\u3059\u3079\u304d\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u793a\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002","title":"\u56de\u8def\u306e\u30b3\u30f3\u30d1\u30a4\u30eb"},{"location":"getting-started/computing-the-witness/","text":"\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97 \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3068\u306f\uff1f \u8a3c\u660e\u3092\u4f5c\u6210\u3059\u308b\u524d\u306b\u3001\u56de\u8def\u306e\u3059\u3079\u3066\u306e\u5236\u7d04\u306b\u4e00\u81f4\u3059\u308b\u56de\u8def\u306e\u3059\u3079\u3066\u306e\u30b7\u30b0\u30ca\u30eb\u3092\u8a08\u7b97\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306b\u3001 circom \u306b\u3088\u3063\u3066\u751f\u6210\u3055\u308c\u305f Wasm \u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\u307e\u305f\u3001 C++ \u306e\u30b3\u30fc\u30c9\u3067\u3082\u540c\u69d8\u306e\u65b9\u6cd5\u3067\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff08\u4e0b\u8a18\u53c2\u7167\uff09\u3002 \u307e\u305a\u3001 Wasm \u306e\u30b3\u30fc\u30c9\u304b\u3089\u898b\u3066\u3044\u304d\u307e\u3057\u3087\u3046\u3002\u751f\u6210\u3055\u308c\u305f Wasm \u30d0\u30a4\u30ca\u30ea\u30683\u3064\u306eJavaScript\u30d5\u30a1\u30a4\u30eb\u3092\u7528\u3044\u3066\u5165\u529b\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u63d0\u4f9b\u3059\u308b\u3060\u3051\u3067\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u56de\u8def\u3092\u5b9f\u884c\u3057\u3066\u3059\u3079\u3066\u306e\u4e2d\u9593\u30b7\u30b0\u30ca\u30eb\u3068\u51fa\u529b\u3092\u8a08\u7b97\u3057\u307e\u3059\u3002\u5165\u529b\u3001\u4e2d\u9593\u30b7\u30b0\u30ca\u30eb\u3001\u51fa\u529b\u306e\u96c6\u5408\u3092 \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9 \u3068\u547c\u3073\u307e\u3059\u3002 \u4eca\u56de\u306f33\u3068\u3044\u3046\u6570\u5024\u306e\u56e0\u6570\u5206\u89e3\u304c\u3067\u304d\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u305f\u3044\u3067\u3059\u3002 a = 3 \u3068 b = 11 \u3068\u3057\u307e\u3057\u3087\u3046\u3002 \u306a\u304a\u3001\u5165\u529b\u306e\u4e00\u65b9\u306b1\u3092\u3001\u3082\u3046\u4e00\u65b9\u306b33\u3092\u3068\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u3002\u3057\u305f\u304c\u3063\u3066\u3001\u3053\u306e\u8a3c\u660e\u306f\u300133\u3068\u3044\u3046\u6570\u5024\u3092\u56e0\u6570\u5206\u89e3\u3067\u304d\u308b\u3053\u3068\u3092\u5b9f\u969b\u306b\u793a\u3057\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002 \u6a19\u6e96\u7684\u306ajson\u5f62\u5f0f\u3067\u66f8\u304b\u308c\u305f\u5165\u529b\u3092\u542b\u3080 input.json \u3068\u3044\u3046\u540d\u524d\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 JavaScript\u306f2 53 \u3088\u308a\u5927\u304d\u306a\u6574\u6570\u3092\u6b63\u78ba\u306b\u6271\u3048\u306a\u3044\u306e\u3067\u3001\u6570\u5024\u306e\u4ee3\u308f\u308a\u306b\u6587\u5b57\u5217\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002 {\"a\": \"3\", \"b\": \"11\"} \u3053\u3053\u3067\u3001\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3092\u8a08\u7b97\u3057\u3001\u305d\u308c\u3092\u542b\u3080\u30d0\u30a4\u30ca\u30ea\u30d5\u30a1\u30a4\u30eb witness.wtns \u3092 snarkjs \u304c\u53d7\u3051\u5165\u308c\u308b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u751f\u6210\u3057\u307e\u3059\u3002 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u30d5\u30e9\u30b0 --wasm \u3068\u56de\u8def multiplier2.circom \u3067\u547c\u3073\u51fa\u3059\u3068\u3001multiplier2.wasm\u306e Wasm \u30b3\u30fc\u30c9\u3068\u5fc5\u8981\u306a JavaScript \u30d5\u30a1\u30a4\u30eb\u3059\u3079\u3066\u3092\u542b\u3080 multiplier2_js \u30d5\u30a9\u30eb\u30c0\u304c\u5f97\u3089\u308c\u307e\u3059\u3002 WebAssembly\u306b\u3088\u308b\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97 \u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_js \u306b\u79fb\u52d5\u3057\u3001\u30d5\u30a1\u30a4\u30eb input.json \u306e\u5165\u529b\u3092\u8ffd\u52a0\u3057\u3066\u3001\u6b21\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002 node generate_witness.js multiplier2.wasm input.json witness.wtns C++\u306b\u3088\u308b\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97 \u3088\u308a\u9ad8\u901f\u306a\u65b9\u6cd5\u3068\u3057\u3066\u3001C++\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u4f7f\u7528\u3057\u3066\u3001\u4ee5\u524d\u306e\u30d5\u30a1\u30a4\u30eb input.json \u3092\u4f7f\u7528\u3057\u3066\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3092\u8a08\u7b97\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f\u3001 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u3092 --c \u306e\u30d5\u30e9\u30b0\u4ed8\u304d\u3067\u4f7f\u7528\u3059\u308b\u3068\u304d\u306b\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97\u306b\u5fc5\u8981\u306a\u3059\u3079\u3066\u306e C++ \u30b3\u30fc\u30c9\u3068\u3001\u5bfe\u5fdc\u3059\u308b\u5b9f\u884c\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7c21\u5358\u306b\u751f\u6210\u3059\u308b\u305f\u3081\u306eMakefile\u3092\u542b\u3080 multiplier2_cpp \u30d5\u30a9\u30eb\u30c0\u30fc\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 \u305d\u306e\u305f\u3081\u306b\u306f\u3001\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_cpp \u306b\u79fb\u52d5\u3057\u3001\u6b21\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002 make \u3053\u306e\u30b3\u30de\u30f3\u30c9\u3067\u306f\u3001 multiplier2 \u3068\u3044\u3046\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002 \u6ce8\u610f: C++\u306e\u30bd\u30fc\u30b9\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u305f\u3081\u306b\u3001\u3042\u306a\u305f\u306e\u30b7\u30b9\u30c6\u30e0\u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\u3044\u304f\u3064\u304b\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u4f9d\u5b58\u3057\u3066\u3044\u307e\u3059\u3002 \u7279\u306b\u3001 nlohmann-json3-dev \u3001 libgmp-dev \u3001 nasm \u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002 \u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u304c\u4f5c\u6210\u3055\u308c\u305f\u5f8c\u3001\u5165\u529b\u30d5\u30a1\u30a4\u30eb\u3068\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u540d\u524d\u3092\u6307\u5b9a\u3057\u3066\u5b9f\u884c\u3057\u307e\u3059\u3002 ./multiplier2 input.json witness.wtns \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u30d5\u30a1\u30a4\u30eb \u3053\u306e2\u3064\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u540c\u3058 \u1e81itness.wtns \u30d5\u30a1\u30a4\u30eb\u3092\u751f\u6210\u3059\u308b\u3002\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u306f\u3001\u5b9f\u969b\u306e\u8a3c\u660e\u306e\u4f5c\u6210\u306b\u4f7f\u7528\u3059\u308b\u30c4\u30fc\u30eb\u3067\u3042\u308b snarkjs \u3068\u4e92\u63db\u6027\u306e\u3042\u308b\u30d0\u30a4\u30ca\u30ea\u5f62\u5f0f\u3067\u30a8\u30f3\u30b3\u30fc\u30c9\u3055\u308c\u3066\u3044\u307e\u3059\u3002 \u6ce8\u610f: \u5927\u304d\u306a\u56de\u8def\u3067\u306e\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97\u306fWASM\u3088\u308aC++\u306e\u65b9\u304c\u65ad\u7136\u901f\u3044\u3067\u3059\u3002","title":"\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97"},{"location":"getting-started/computing-the-witness/#_1","text":"","title":"\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97"},{"location":"getting-started/computing-the-witness/#_2","text":"\u8a3c\u660e\u3092\u4f5c\u6210\u3059\u308b\u524d\u306b\u3001\u56de\u8def\u306e\u3059\u3079\u3066\u306e\u5236\u7d04\u306b\u4e00\u81f4\u3059\u308b\u56de\u8def\u306e\u3059\u3079\u3066\u306e\u30b7\u30b0\u30ca\u30eb\u3092\u8a08\u7b97\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306b\u3001 circom \u306b\u3088\u3063\u3066\u751f\u6210\u3055\u308c\u305f Wasm \u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002\u307e\u305f\u3001 C++ \u306e\u30b3\u30fc\u30c9\u3067\u3082\u540c\u69d8\u306e\u65b9\u6cd5\u3067\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff08\u4e0b\u8a18\u53c2\u7167\uff09\u3002 \u307e\u305a\u3001 Wasm \u306e\u30b3\u30fc\u30c9\u304b\u3089\u898b\u3066\u3044\u304d\u307e\u3057\u3087\u3046\u3002\u751f\u6210\u3055\u308c\u305f Wasm \u30d0\u30a4\u30ca\u30ea\u30683\u3064\u306eJavaScript\u30d5\u30a1\u30a4\u30eb\u3092\u7528\u3044\u3066\u5165\u529b\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u63d0\u4f9b\u3059\u308b\u3060\u3051\u3067\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u56de\u8def\u3092\u5b9f\u884c\u3057\u3066\u3059\u3079\u3066\u306e\u4e2d\u9593\u30b7\u30b0\u30ca\u30eb\u3068\u51fa\u529b\u3092\u8a08\u7b97\u3057\u307e\u3059\u3002\u5165\u529b\u3001\u4e2d\u9593\u30b7\u30b0\u30ca\u30eb\u3001\u51fa\u529b\u306e\u96c6\u5408\u3092 \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9 \u3068\u547c\u3073\u307e\u3059\u3002 \u4eca\u56de\u306f33\u3068\u3044\u3046\u6570\u5024\u306e\u56e0\u6570\u5206\u89e3\u304c\u3067\u304d\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u305f\u3044\u3067\u3059\u3002 a = 3 \u3068 b = 11 \u3068\u3057\u307e\u3057\u3087\u3046\u3002 \u306a\u304a\u3001\u5165\u529b\u306e\u4e00\u65b9\u306b1\u3092\u3001\u3082\u3046\u4e00\u65b9\u306b33\u3092\u3068\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u3002\u3057\u305f\u304c\u3063\u3066\u3001\u3053\u306e\u8a3c\u660e\u306f\u300133\u3068\u3044\u3046\u6570\u5024\u3092\u56e0\u6570\u5206\u89e3\u3067\u304d\u308b\u3053\u3068\u3092\u5b9f\u969b\u306b\u793a\u3057\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002 \u6a19\u6e96\u7684\u306ajson\u5f62\u5f0f\u3067\u66f8\u304b\u308c\u305f\u5165\u529b\u3092\u542b\u3080 input.json \u3068\u3044\u3046\u540d\u524d\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f5c\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 JavaScript\u306f2 53 \u3088\u308a\u5927\u304d\u306a\u6574\u6570\u3092\u6b63\u78ba\u306b\u6271\u3048\u306a\u3044\u306e\u3067\u3001\u6570\u5024\u306e\u4ee3\u308f\u308a\u306b\u6587\u5b57\u5217\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059\u3002 {\"a\": \"3\", \"b\": \"11\"} \u3053\u3053\u3067\u3001\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3092\u8a08\u7b97\u3057\u3001\u305d\u308c\u3092\u542b\u3080\u30d0\u30a4\u30ca\u30ea\u30d5\u30a1\u30a4\u30eb witness.wtns \u3092 snarkjs \u304c\u53d7\u3051\u5165\u308c\u308b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u751f\u6210\u3057\u307e\u3059\u3002 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u3092\u30d5\u30e9\u30b0 --wasm \u3068\u56de\u8def multiplier2.circom \u3067\u547c\u3073\u51fa\u3059\u3068\u3001multiplier2.wasm\u306e Wasm \u30b3\u30fc\u30c9\u3068\u5fc5\u8981\u306a JavaScript \u30d5\u30a1\u30a4\u30eb\u3059\u3079\u3066\u3092\u542b\u3080 multiplier2_js \u30d5\u30a9\u30eb\u30c0\u304c\u5f97\u3089\u308c\u307e\u3059\u3002","title":"\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3068\u306f\uff1f"},{"location":"getting-started/computing-the-witness/#webassembly","text":"\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_js \u306b\u79fb\u52d5\u3057\u3001\u30d5\u30a1\u30a4\u30eb input.json \u306e\u5165\u529b\u3092\u8ffd\u52a0\u3057\u3066\u3001\u6b21\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002 node generate_witness.js multiplier2.wasm input.json witness.wtns","title":"WebAssembly\u306b\u3088\u308b\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97 "},{"location":"getting-started/computing-the-witness/#c","text":"\u3088\u308a\u9ad8\u901f\u306a\u65b9\u6cd5\u3068\u3057\u3066\u3001C++\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u4f7f\u7528\u3057\u3066\u3001\u4ee5\u524d\u306e\u30d5\u30a1\u30a4\u30eb input.json \u3092\u4f7f\u7528\u3057\u3066\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u3092\u8a08\u7b97\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306f\u3001 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u3092 --c \u306e\u30d5\u30e9\u30b0\u4ed8\u304d\u3067\u4f7f\u7528\u3059\u308b\u3068\u304d\u306b\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\u3053\u306e\u4f8b\u3067\u306f\u3001\u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97\u306b\u5fc5\u8981\u306a\u3059\u3079\u3066\u306e C++ \u30b3\u30fc\u30c9\u3068\u3001\u5bfe\u5fdc\u3059\u308b\u5b9f\u884c\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u7c21\u5358\u306b\u751f\u6210\u3059\u308b\u305f\u3081\u306eMakefile\u3092\u542b\u3080 multiplier2_cpp \u30d5\u30a9\u30eb\u30c0\u30fc\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002 \u305d\u306e\u305f\u3081\u306b\u306f\u3001\u30c7\u30a3\u30ec\u30af\u30c8\u30ea multiplier2_cpp \u306b\u79fb\u52d5\u3057\u3001\u6b21\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002 make \u3053\u306e\u30b3\u30de\u30f3\u30c9\u3067\u306f\u3001 multiplier2 \u3068\u3044\u3046\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002 \u6ce8\u610f: C++\u306e\u30bd\u30fc\u30b9\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u305f\u3081\u306b\u3001\u3042\u306a\u305f\u306e\u30b7\u30b9\u30c6\u30e0\u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\u3044\u304f\u3064\u304b\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u4f9d\u5b58\u3057\u3066\u3044\u307e\u3059\u3002 \u7279\u306b\u3001 nlohmann-json3-dev \u3001 libgmp-dev \u3001 nasm \u3092\u4f7f\u7528\u3057\u3066\u3044\u307e\u3059\u3002 \u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u304c\u4f5c\u6210\u3055\u308c\u305f\u5f8c\u3001\u5165\u529b\u30d5\u30a1\u30a4\u30eb\u3068\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u30d5\u30a1\u30a4\u30eb\u306e\u540d\u524d\u3092\u6307\u5b9a\u3057\u3066\u5b9f\u884c\u3057\u307e\u3059\u3002 ./multiplier2 input.json witness.wtns","title":"C++\u306b\u3088\u308b\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97 "},{"location":"getting-started/computing-the-witness/#_3","text":"\u3053\u306e2\u3064\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u540c\u3058 \u1e81itness.wtns \u30d5\u30a1\u30a4\u30eb\u3092\u751f\u6210\u3059\u308b\u3002\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u306f\u3001\u5b9f\u969b\u306e\u8a3c\u660e\u306e\u4f5c\u6210\u306b\u4f7f\u7528\u3059\u308b\u30c4\u30fc\u30eb\u3067\u3042\u308b snarkjs \u3068\u4e92\u63db\u6027\u306e\u3042\u308b\u30d0\u30a4\u30ca\u30ea\u5f62\u5f0f\u3067\u30a8\u30f3\u30b3\u30fc\u30c9\u3055\u308c\u3066\u3044\u307e\u3059\u3002 \u6ce8\u610f: \u5927\u304d\u306a\u56de\u8def\u3067\u306e\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97\u306fWASM\u3088\u308aC++\u306e\u65b9\u304c\u65ad\u7136\u901f\u3044\u3067\u3059\u3002","title":"\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u30d5\u30a1\u30a4\u30eb"},{"location":"getting-started/installation/","text":"circom\u30a8\u30b3\u30b7\u30b9\u30c6\u30e0\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb \u26a0 \u91cd\u8981\u306a\u63a8\u5968\u4e8b\u9805 JavaScript\u3067\u66f8\u304b\u308c\u305f\u65e7 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u5c06\u6765\u7684\u306b\u51cd\u7d50\u3055\u308c\u307e\u3059\u304c\u3001 \u53e4\u3044circom\u30ea\u30dd\u30b8\u30c8\u30ea \u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3059\u308b\u3053\u3068\u306f\u53ef\u80fd\u3067\u3059\u3002 \u4f9d\u5b58\u95a2\u4fc2\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb circom \u3068\u305d\u306e\u95a2\u9023\u30c4\u30fc\u30eb\u3092\u5b9f\u884c\u3059\u308b\u305f\u3081\u306b\u3001\u30b7\u30b9\u30c6\u30e0\u306b\u3044\u304f\u3064\u304b\u306e\u4f9d\u5b58\u95a2\u4fc2\u304c\u5fc5\u8981\u3067\u3059\u3002 \u30b3\u30a2\u3068\u306a\u308b\u30c4\u30fc\u30eb\u306f\u3001Rust\u3067\u66f8\u304b\u308c\u305f circom \u30b3\u30f3\u30d1\u30a4\u30e9\u3067\u3059\u3002 Rust\u3092\u5229\u7528\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\u306b\u306f\u3001 rustup \u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u307e\u3059\u3002Linux\u3084macOS\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u30bf\u30fc\u30df\u30ca\u30eb\u3092\u958b\u3044\u3066\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5165\u529b\u3057\u307e\u3059\u3002 curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh \u307e\u305f\u3001\u4e00\u9023\u306enpm\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u914d\u5e03\u3057\u3066\u3044\u308b\u306e\u3067\u3001 Node.js \u3068 npm \u3084 yarn \u306a\u3069\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u30de\u30cd\u30fc\u30b8\u30e3\u304c\u30b7\u30b9\u30c6\u30e0\u3067\u5229\u7528\u53ef\u80fd\u3067\u3042\u308b\u306f\u305a\u3067\u3059\u3002 Node.js \u306e\u6700\u8fd1\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u306f\u3001\u5927\u304d\u306a\u6574\u6570\u306e\u30b5\u30dd\u30fc\u30c8\u3084\u3001\u30b3\u30fc\u30c9\u306e\u5b9f\u884c\u3092\u9ad8\u901f\u5316\u3059\u308b\u30a6\u30a7\u30d6\u30a2\u30bb\u30f3\u30d6\u30ea\u30b3\u30f3\u30d1\u30a4\u30e9\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u3088\u308a\u826f\u3044\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5f97\u308b\u306b\u306f\u3001\u30d0\u30fc\u30b8\u30e7\u30f310\u4ee5\u4e0a\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\u304f\u3060\u3055\u3044\u3002 circom\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb \u79c1\u305f\u3061\u306e\u30bd\u30fc\u30b9\u304b\u3089\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u306b\u306f\u3001 circom \u30ea\u30dd\u30b8\u30c8\u30ea\u3092\u30af\u30ed\u30fc\u30f3\u3057\u3066\u304f\u3060\u3055\u3044\u3002 git clone https://github.com/iden3/circom.git circom\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u5165\u308a\u3001cargo build\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u307e\u3059\u3002 cargo build --release \u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u304c\u5b8c\u4e86\u3059\u308b\u307e\u3067\u306b\u306f3\u5206\u7a0b\u5ea6\u304b\u304b\u308a\u307e\u3059\u3002 \u30b3\u30de\u30f3\u30c9\u304c\u6b63\u5e38\u306b\u7d42\u4e86\u3059\u308b\u3068\u3001\u30c7\u30a3\u30ec\u30af\u30c8\u30ea target/release \u306b circom \u306e\u30d0\u30a4\u30ca\u30ea\u304c\u751f\u6210\u3055\u308c\u307e\u3059\u3002 \u3053\u306e\u30d0\u30a4\u30ca\u30ea\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u306b\u306f\u3001\u6b21\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002 cargo install --path circom \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u3001 circom \u306e\u30d0\u30a4\u30ca\u30ea\u3092\u30c7\u30a3\u30ec\u30af\u30c8\u30ea $HOME/.cargo/bin \u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u307e\u3059\u3002 \u3053\u308c\u3067\u3001 help \u30d5\u30e9\u30b0\u3092\u4f7f\u3048\u3070\u3001\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u306e\u3059\u3079\u3066\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u898b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\u306f\u305a\u3067\u3059\u3002 circom --help Circom Compiler 2.0.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom] snarkjs\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb snarkjs \u306f\u3001 circom \u3067\u751f\u6210\u3055\u308c\u305f\u30a2\u30fc\u30c6\u30a3\u30d5\u30a1\u30af\u30c8\u304b\u3089\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u3092\u751f\u6210\u30fb\u691c\u8a3c\u3059\u308b\u30b3\u30fc\u30c9\u3092\u542b\u3080npm\u30d1\u30c3\u30b1\u30fc\u30b8\u3067\u3059\u3002 snarkjs \u306f\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3067\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3067\u304d\u307e\u3059\u3002 npm install -g snarkjs","title":"\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb"},{"location":"getting-started/installation/#circom","text":"","title":"circom\u30a8\u30b3\u30b7\u30b9\u30c6\u30e0\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb"},{"location":"getting-started/installation/#_1","text":"JavaScript\u3067\u66f8\u304b\u308c\u305f\u65e7 circom \u30b3\u30f3\u30d1\u30a4\u30e9\u306f\u5c06\u6765\u7684\u306b\u51cd\u7d50\u3055\u308c\u307e\u3059\u304c\u3001 \u53e4\u3044circom\u30ea\u30dd\u30b8\u30c8\u30ea \u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3059\u308b\u3053\u3068\u306f\u53ef\u80fd\u3067\u3059\u3002","title":"&#9888; \u91cd\u8981\u306a\u63a8\u5968\u4e8b\u9805"},{"location":"getting-started/installation/#_2","text":"circom \u3068\u305d\u306e\u95a2\u9023\u30c4\u30fc\u30eb\u3092\u5b9f\u884c\u3059\u308b\u305f\u3081\u306b\u3001\u30b7\u30b9\u30c6\u30e0\u306b\u3044\u304f\u3064\u304b\u306e\u4f9d\u5b58\u95a2\u4fc2\u304c\u5fc5\u8981\u3067\u3059\u3002 \u30b3\u30a2\u3068\u306a\u308b\u30c4\u30fc\u30eb\u306f\u3001Rust\u3067\u66f8\u304b\u308c\u305f circom \u30b3\u30f3\u30d1\u30a4\u30e9\u3067\u3059\u3002 Rust\u3092\u5229\u7528\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\u306b\u306f\u3001 rustup \u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u307e\u3059\u3002Linux\u3084macOS\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u30bf\u30fc\u30df\u30ca\u30eb\u3092\u958b\u3044\u3066\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5165\u529b\u3057\u307e\u3059\u3002 curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh \u307e\u305f\u3001\u4e00\u9023\u306enpm\u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u914d\u5e03\u3057\u3066\u3044\u308b\u306e\u3067\u3001 Node.js \u3068 npm \u3084 yarn \u306a\u3069\u306e\u30d1\u30c3\u30b1\u30fc\u30b8\u30de\u30cd\u30fc\u30b8\u30e3\u304c\u30b7\u30b9\u30c6\u30e0\u3067\u5229\u7528\u53ef\u80fd\u3067\u3042\u308b\u306f\u305a\u3067\u3059\u3002 Node.js \u306e\u6700\u8fd1\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u306f\u3001\u5927\u304d\u306a\u6574\u6570\u306e\u30b5\u30dd\u30fc\u30c8\u3084\u3001\u30b3\u30fc\u30c9\u306e\u5b9f\u884c\u3092\u9ad8\u901f\u5316\u3059\u308b\u30a6\u30a7\u30d6\u30a2\u30bb\u30f3\u30d6\u30ea\u30b3\u30f3\u30d1\u30a4\u30e9\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u3088\u308a\u826f\u3044\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u3092\u5f97\u308b\u306b\u306f\u3001\u30d0\u30fc\u30b8\u30e7\u30f310\u4ee5\u4e0a\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3066\u304f\u3060\u3055\u3044\u3002","title":"\u4f9d\u5b58\u95a2\u4fc2\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb"},{"location":"getting-started/installation/#circom_1","text":"\u79c1\u305f\u3061\u306e\u30bd\u30fc\u30b9\u304b\u3089\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u306b\u306f\u3001 circom \u30ea\u30dd\u30b8\u30c8\u30ea\u3092\u30af\u30ed\u30fc\u30f3\u3057\u3066\u304f\u3060\u3055\u3044\u3002 git clone https://github.com/iden3/circom.git circom\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u5165\u308a\u3001cargo build\u3067\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u307e\u3059\u3002 cargo build --release \u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u304c\u5b8c\u4e86\u3059\u308b\u307e\u3067\u306b\u306f3\u5206\u7a0b\u5ea6\u304b\u304b\u308a\u307e\u3059\u3002 \u30b3\u30de\u30f3\u30c9\u304c\u6b63\u5e38\u306b\u7d42\u4e86\u3059\u308b\u3068\u3001\u30c7\u30a3\u30ec\u30af\u30c8\u30ea target/release \u306b circom \u306e\u30d0\u30a4\u30ca\u30ea\u304c\u751f\u6210\u3055\u308c\u307e\u3059\u3002 \u3053\u306e\u30d0\u30a4\u30ca\u30ea\u3092\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3059\u308b\u306b\u306f\u3001\u6b21\u306e\u3088\u3046\u306b\u3057\u307e\u3059\u3002 cargo install --path circom \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u3001 circom \u306e\u30d0\u30a4\u30ca\u30ea\u3092\u30c7\u30a3\u30ec\u30af\u30c8\u30ea $HOME/.cargo/bin \u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u307e\u3059\u3002 \u3053\u308c\u3067\u3001 help \u30d5\u30e9\u30b0\u3092\u4f7f\u3048\u3070\u3001\u5b9f\u884c\u30d5\u30a1\u30a4\u30eb\u306e\u3059\u3079\u3066\u306e\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u898b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\u306f\u305a\u3067\u3059\u3002 circom --help Circom Compiler 2.0.0 IDEN3 Compiler for the Circom programming language USAGE: circom [FLAGS] [OPTIONS] [input] FLAGS: -h, --help Prints help information --inspect Does an additional check over the constraints produced --O0 No simplification is applied -c, --c Compiles the circuit to c --json outputs the constraints in json format --r1cs outputs the constraints in r1cs format --sym outputs witness in sym format --wasm Compiles the circuit to wasm --wat Compiles the circuit to wat --O1 Only applies var to var and var to constant simplification -V, --version Prints version information OPTIONS: --O2 <full_simplification> Full constraint simplification [default: full] -o, --output <output> Path to the directory where the output will be written [default: .] ARGS: <input> Path to a circuit with a main component [default: ./circuit.circom]","title":"circom\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb"},{"location":"getting-started/installation/#snarkjs","text":"snarkjs \u306f\u3001 circom \u3067\u751f\u6210\u3055\u308c\u305f\u30a2\u30fc\u30c6\u30a3\u30d5\u30a1\u30af\u30c8\u304b\u3089\u30bc\u30ed\u77e5\u8b58\u8a3c\u660e\u3092\u751f\u6210\u30fb\u691c\u8a3c\u3059\u308b\u30b3\u30fc\u30c9\u3092\u542b\u3080npm\u30d1\u30c3\u30b1\u30fc\u30b8\u3067\u3059\u3002 snarkjs \u306f\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3067\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3067\u304d\u307e\u3059\u3002 npm install -g snarkjs","title":"snarkjs\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb "},{"location":"getting-started/proving-circuits/","text":"\u56de\u8def\u306e\u8a3c\u660e \u56de\u8def\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3001\u9069\u5207\u306a\u5165\u529b\u3067\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97\u3092\u5b9f\u884c\u3092\u3059\u308b\u3068\u3001\u8a08\u7b97\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u30b7\u30b0\u30ca\u30eb\u3092\u542b\u3080.wtns\u3068\u3044\u3046\u62e1\u5f35\u5b50\u306e\u30d5\u30a1\u30a4\u30eb\u3068\u3001\u56de\u8def\u3092\u8a18\u8ff0\u3059\u308b\u5236\u7d04\u3092\u542b\u3080.r1cs\u3068\u3044\u3046\u62e1\u5f35\u5b50\u306e\u30d5\u30a1\u30a4\u30eb\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\u4e21\u30d5\u30a1\u30a4\u30eb\u306f\u8a3c\u660e\u306e\u4f5c\u6210\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002 \u3067\u306f\u3001 snarkjs \u30c4\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u3001\u5165\u529b\u306b\u5bfe\u3059\u308b\u8a3c\u660e\u3092\u751f\u6210\u3057\u3001\u691c\u8a3c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u7279\u306b\u3001multiplier2\u3092\u4f7f\u3063\u3066\u3001 33\u306e2\u3064\u306e\u56e0\u6570\u3092\u63d0\u4f9b\u3067\u304d\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u307e\u3059\u3002 \u3064\u307e\u308a\u30012\u3064\u306e\u6574\u6570 a \u3068 b \u3092\u639b\u3051\u5408\u308f\u305b\u308b\u306833\u3068\u3044\u3046\u6570\u5024\u306b\u306a\u308b\u3088\u3046\u306a\u3082\u306e\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u793a\u3059\u306e\u3067\u3059\u3002 Groth16 zk-SNARK\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002 \u3053\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u4f7f\u7528\u3059\u308b\u306b\u306f\u3001 Trusted Setup \u3092\u751f\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 Groth16\u306f\u56de\u8def\u3054\u3068\u306bTrusted Setup\u304c\u5fc5\u8981\u3067\u3059 \u3002\u3088\u308a\u8a73\u7d30\u306b\u306f\u3001Trusted Setup\u306f2\u3064\u306e\u90e8\u5206\u304b\u3089\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\u3002 Powers of Tau\u3002\u56de\u8def\u306b\u4f9d\u5b58\u3057\u306a\u3044\u3002 Phase 2\u3002\u56de\u8def\u306b\u4f9d\u5b58\u3059\u308b\u3002 \u6b21\u306b\u3001Trusted Setup\u3092\u4f5c\u6210\u3059\u308b\u305f\u3081\u306e\u975e\u5e38\u306b\u57fa\u672c\u7684\u306a\u30bb\u30ec\u30e2\u30cb\u30fc\u3068\u3001 Groth16 \u8a3c\u660e\u306e\u4f5c\u6210\u30fb\u691c\u8a3c\u306e\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u30b3\u30de\u30f3\u30c9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\u95a2\u9023\u3059\u308b \u80cc\u666f \u3092\u78ba\u8a8d\u3057\u3001 snarkjs\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb \u3092\u78ba\u8a8d\u3059\u308b\u3053\u3068\u3067\u3001\u3088\u308a\u8a73\u7d30\u306a\u60c5\u5831\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 Powers of Tau \u307e\u305a\u3001\u65b0\u3057\u3044\u300cPowers of Tau\u300d\u306e\u30bb\u30ec\u30e2\u30cb\u30fc\u3092\u958b\u59cb\u3057\u307e\u3059\u3002 snarkjs powersoftau new bn128 12 pot12_0000.ptau -v \u6b21\u306b\u3001\u30bb\u30ec\u30e2\u30cb\u30fc\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u3057\u307e\u3059\u3002 snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v \u3053\u308c\u3067\u3001Powers of Tau\u3078\u306e\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u304c\u30d5\u30a1\u30a4\u30eb pot12_0001.ptau \u306b\u683c\u7d0d\u3055\u308c\u305f\u306e\u3067\u3001Phase 2\u306b\u9032\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002 Phase 2 Phase 2 \u306f circuit-specific \u3067\u3059\u3002 \u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u3001\u3053\u306e\u30d5\u30a7\u30fc\u30ba\u306e\u751f\u6210\u304c\u958b\u59cb\u3055\u308c\u307e\u3059\u3002 snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v \u6b21\u306b\u3001Phase 2\u3067\u4f7f\u7528\u3059\u308b\u8a3c\u660e\u9375\u3068\u691c\u8a3c\u9375\u3092\u542b\u3080 .zkey \u30d5\u30a1\u30a4\u30eb\u3092\u751f\u6210\u3057\u307e\u3059\u3002 \u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3001\u65b0\u3057\u3044zkey\u3092\u59cb\u3081\u307e\u3059\u3002 snarkjs groth16 setup multiplier2.r1cs pot12_final.ptau multiplier2_0000.zkey Phase 2\u30bb\u30ec\u30e2\u30cb\u30fc\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u3057\u307e\u3059\u3002 snarkjs zkey contribute multiplier2_0000.zkey multiplier2_0001.zkey --name=\"1st Contributor Name\" -v \u691c\u8a3c\u9375\u3092\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3057\u307e\u3059\u3002 snarkjs zkey export verificationkey multiplier2_0001.zkey verification_key.json \u8a3c\u660e\u306e\u751f\u6210 \u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u304c\u8a08\u7b97\u3055\u308c\u3001Trusted Setup\u304c\u5b9f\u884c\u6e08\u307f\u3067\u3042\u308c\u3070\u3001\u56de\u8def\u3068\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306b\u95a2\u9023\u3059\u308b zk-proof\u306e\u751f\u6210 \u304c\u3067\u304d\u307e\u3059\u3002 snarkjs groth16 prove multiplier2_0001.zkey witness.wtns proof.json public.json \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u3001 Groth16 \u30d7\u30eb\u30fc\u30d5\u3092\u751f\u6210\u3057\u30012\u3064\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 proof.json : \u8a3c\u660e\u3092\u542b\u307f\u307e\u3059\u3002 public.json : \u516c\u958b\u3055\u308c\u305f\u5165\u51fa\u529b\u306e\u5024\u3092\u542b\u307f\u307e\u3059\u3002 \u8a3c\u660e\u306e\u691c\u8a3c \u8a3c\u660e\u306e\u691c\u8a3c \u3092\u3059\u308b\u306b\u306f\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002 snarkjs groth16 verify verification_key.json public.json proof.json \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u3001\u5148\u307b\u3069\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3057\u305f verification_key.json \u3001 proof.json \u3001 public.json \u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u3063\u3066\u3001\u8a3c\u660e\u304c\u6709\u52b9\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3057\u307e\u3059\u3002\u8a3c\u660e\u304c\u6709\u52b9\u306a\u5834\u5408\u3001\u30b3\u30de\u30f3\u30c9\u306f OK \u3092\u51fa\u529b\u3057\u307e\u3059\u3002 \u6709\u52b9\u306a\u8a3c\u660e\u306f\u3001\u56de\u8def\u3092\u6e80\u305f\u3059\u30b7\u30b0\u30ca\u30eb\u306e\u30bb\u30c3\u30c8\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u8a3c\u660e\u3059\u308b\u3060\u3051\u3067\u306a\u304f\u3001\u4f7f\u7528\u3059\u308b\u516c\u958b\u5165\u51fa\u529b\u304c public.json \u30d5\u30a1\u30a4\u30eb\u306b\u8a18\u8ff0\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u3068\u4e00\u81f4\u3059\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u307e\u3059\u3002 \u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3067\u306e\u691c\u8a3c \ud83d\udc49 Ethereum\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3067\u8a3c\u660e\u3092\u691c\u8a3c \u3067\u304d\u308b Solidity\u691c\u8a3c\u5668 \u3092\u751f\u6210\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u3002 \u307e\u305a\u3001Solidity\u306e\u30b3\u30fc\u30c9\u3092\u30b3\u30de\u30f3\u30c9\u3067\u751f\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 snarkjs zkey export solidityverifier multiplier2_0001.zkey verifier.sol \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u691c\u8a3c\u9375 multiplier2_0001.zkey \u3092\u53d7\u3051\u53d6\u308a\u3001Solidity\u306e\u30b3\u30fc\u30c9\u3092 verifier.sol \u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3057\u307e\u3059\u3002\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30b3\u30fc\u30c9\u3092\u53d6\u308a\u51fa\u3057\u3001Remix\u306b\u30ab\u30c3\u30c8\uff06\u30da\u30fc\u30b9\u30c8\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u30b3\u30fc\u30c9\u306b\u306f2\u3064\u306e\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002 Pairing \u3068 Verifier \u3067\u3059\u3002 Verifier \u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u307f\u3092\u30c7\u30d7\u30ed\u30a4\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 Rinkeby\u3001Kovan\u3001Ropsten\u306e\u3088\u3046\u306a\u30c6\u30b9\u30c8\u30cd\u30c3\u30c8\u3092\u6700\u521d\u306b\u4f7f\u7528\u3059\u308b\u3068\u3088\u3044\u3067\u3057\u3087\u3046\u3002JavaScript VM\u3092\u4f7f\u3046\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u304c\u3001\u30d6\u30e9\u30a6\u30b6\u306b\u3088\u3063\u3066\u306f\u691c\u8a3c\u306b\u6642\u9593\u304c\u304b\u304b\u308a\u3001\u30da\u30fc\u30b8\u304c\u30d5\u30ea\u30fc\u30ba\u3059\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\u3002 Verifier \u306b\u306f verifyProof \u3068\u3044\u3046 view \u95a2\u6570\u304c\u3042\u308a\u3001\u8a3c\u660e\u3068\u5165\u529b\u304c\u6709\u52b9\u3067\u3042\u308b\u5834\u5408\u306b\u306e\u307f TRUE \u3092\u8fd4\u3057\u307e\u3059\u3002\u547c\u3073\u51fa\u3057\u3092\u5bb9\u6613\u306b\u3059\u308b\u305f\u3081\u306b\u3001 snarkJS \u3092\u4f7f\u7528\u3057\u3066\u3001\u5165\u529b\u306b\u3088\u3063\u3066\u30b3\u30fc\u30eb\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u751f\u6210\u3067\u304d\u307e\u3059\u3002 snarkjs generatecall \u30b3\u30de\u30f3\u30c9\u306e\u51fa\u529b\u3092Remix\u306e verifyProof \u30e1\u30bd\u30c3\u30c9\u306eparameters\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u30ab\u30c3\u30c8\uff06\u30da\u30fc\u30b9\u30c8\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3059\u3079\u3066\u304c\u3046\u307e\u304f\u3044\u3051\u3070\u3001\u3053\u306e\u30e1\u30bd\u30c3\u30c9\u306f TRUE \u3092\u8fd4\u3059\u306f\u305a\u3067\u3059\u3002\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u307b\u3093\u306e1\u30d3\u30c3\u30c8\u3092\u5909\u66f4\u3057\u3066\u307f\u308b\u3068\u3001\u691c\u8a3c\u53ef\u80fd\u306a FALSE \u3068\u306a\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002","title":"\u30bc\u30ed\u77e5\u8b58\u306b\u3088\u308b\u56de\u8def\u306e\u8a3c\u660e"},{"location":"getting-started/proving-circuits/#_1","text":"\u56de\u8def\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3001\u9069\u5207\u306a\u5165\u529b\u3067\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306e\u8a08\u7b97\u3092\u5b9f\u884c\u3092\u3059\u308b\u3068\u3001\u8a08\u7b97\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u30b7\u30b0\u30ca\u30eb\u3092\u542b\u3080.wtns\u3068\u3044\u3046\u62e1\u5f35\u5b50\u306e\u30d5\u30a1\u30a4\u30eb\u3068\u3001\u56de\u8def\u3092\u8a18\u8ff0\u3059\u308b\u5236\u7d04\u3092\u542b\u3080.r1cs\u3068\u3044\u3046\u62e1\u5f35\u5b50\u306e\u30d5\u30a1\u30a4\u30eb\u304c\u4f5c\u6210\u3055\u308c\u307e\u3059\u3002\u4e21\u30d5\u30a1\u30a4\u30eb\u306f\u8a3c\u660e\u306e\u4f5c\u6210\u306b\u4f7f\u7528\u3055\u308c\u307e\u3059\u3002 \u3067\u306f\u3001 snarkjs \u30c4\u30fc\u30eb\u3092\u4f7f\u3063\u3066\u3001\u5165\u529b\u306b\u5bfe\u3059\u308b\u8a3c\u660e\u3092\u751f\u6210\u3057\u3001\u691c\u8a3c\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002\u7279\u306b\u3001multiplier2\u3092\u4f7f\u3063\u3066\u3001 33\u306e2\u3064\u306e\u56e0\u6570\u3092\u63d0\u4f9b\u3067\u304d\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u307e\u3059\u3002 \u3064\u307e\u308a\u30012\u3064\u306e\u6574\u6570 a \u3068 b \u3092\u639b\u3051\u5408\u308f\u305b\u308b\u306833\u3068\u3044\u3046\u6570\u5024\u306b\u306a\u308b\u3088\u3046\u306a\u3082\u306e\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u793a\u3059\u306e\u3067\u3059\u3002 Groth16 zk-SNARK\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u4f7f\u7528\u3057\u307e\u3059\u3002 \u3053\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u4f7f\u7528\u3059\u308b\u306b\u306f\u3001 Trusted Setup \u3092\u751f\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 Groth16\u306f\u56de\u8def\u3054\u3068\u306bTrusted Setup\u304c\u5fc5\u8981\u3067\u3059 \u3002\u3088\u308a\u8a73\u7d30\u306b\u306f\u3001Trusted Setup\u306f2\u3064\u306e\u90e8\u5206\u304b\u3089\u69cb\u6210\u3055\u308c\u3066\u3044\u307e\u3059\u3002 Powers of Tau\u3002\u56de\u8def\u306b\u4f9d\u5b58\u3057\u306a\u3044\u3002 Phase 2\u3002\u56de\u8def\u306b\u4f9d\u5b58\u3059\u308b\u3002 \u6b21\u306b\u3001Trusted Setup\u3092\u4f5c\u6210\u3059\u308b\u305f\u3081\u306e\u975e\u5e38\u306b\u57fa\u672c\u7684\u306a\u30bb\u30ec\u30e2\u30cb\u30fc\u3068\u3001 Groth16 \u8a3c\u660e\u306e\u4f5c\u6210\u30fb\u691c\u8a3c\u306e\u305f\u3081\u306e\u57fa\u672c\u7684\u306a\u30b3\u30de\u30f3\u30c9\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\u95a2\u9023\u3059\u308b \u80cc\u666f \u3092\u78ba\u8a8d\u3057\u3001 snarkjs\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb \u3092\u78ba\u8a8d\u3059\u308b\u3053\u3068\u3067\u3001\u3088\u308a\u8a73\u7d30\u306a\u60c5\u5831\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002","title":"\u56de\u8def\u306e\u8a3c\u660e"},{"location":"getting-started/proving-circuits/#powers-of-tau","text":"\u307e\u305a\u3001\u65b0\u3057\u3044\u300cPowers of Tau\u300d\u306e\u30bb\u30ec\u30e2\u30cb\u30fc\u3092\u958b\u59cb\u3057\u307e\u3059\u3002 snarkjs powersoftau new bn128 12 pot12_0000.ptau -v \u6b21\u306b\u3001\u30bb\u30ec\u30e2\u30cb\u30fc\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u3057\u307e\u3059\u3002 snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=\"First contribution\" -v \u3053\u308c\u3067\u3001Powers of Tau\u3078\u306e\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u304c\u30d5\u30a1\u30a4\u30eb pot12_0001.ptau \u306b\u683c\u7d0d\u3055\u308c\u305f\u306e\u3067\u3001Phase 2\u306b\u9032\u3080\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002","title":"Powers of Tau "},{"location":"getting-started/proving-circuits/#phase-2","text":"Phase 2 \u306f circuit-specific \u3067\u3059\u3002 \u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3059\u308b\u3068\u3001\u3053\u306e\u30d5\u30a7\u30fc\u30ba\u306e\u751f\u6210\u304c\u958b\u59cb\u3055\u308c\u307e\u3059\u3002 snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v \u6b21\u306b\u3001Phase 2\u3067\u4f7f\u7528\u3059\u308b\u8a3c\u660e\u9375\u3068\u691c\u8a3c\u9375\u3092\u542b\u3080 .zkey \u30d5\u30a1\u30a4\u30eb\u3092\u751f\u6210\u3057\u307e\u3059\u3002 \u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u3001\u65b0\u3057\u3044zkey\u3092\u59cb\u3081\u307e\u3059\u3002 snarkjs groth16 setup multiplier2.r1cs pot12_final.ptau multiplier2_0000.zkey Phase 2\u30bb\u30ec\u30e2\u30cb\u30fc\u306b\u30b3\u30f3\u30c8\u30ea\u30d3\u30e5\u30fc\u30b7\u30e7\u30f3\u3057\u307e\u3059\u3002 snarkjs zkey contribute multiplier2_0000.zkey multiplier2_0001.zkey --name=\"1st Contributor Name\" -v \u691c\u8a3c\u9375\u3092\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3057\u307e\u3059\u3002 snarkjs zkey export verificationkey multiplier2_0001.zkey verification_key.json","title":"Phase 2 "},{"location":"getting-started/proving-circuits/#_2","text":"\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u304c\u8a08\u7b97\u3055\u308c\u3001Trusted Setup\u304c\u5b9f\u884c\u6e08\u307f\u3067\u3042\u308c\u3070\u3001\u56de\u8def\u3068\u30a6\u30a3\u30c3\u30c8\u30cd\u30b9\u306b\u95a2\u9023\u3059\u308b zk-proof\u306e\u751f\u6210 \u304c\u3067\u304d\u307e\u3059\u3002 snarkjs groth16 prove multiplier2_0001.zkey witness.wtns proof.json public.json \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u3001 Groth16 \u30d7\u30eb\u30fc\u30d5\u3092\u751f\u6210\u3057\u30012\u3064\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u51fa\u529b\u3057\u307e\u3059\u3002 proof.json : \u8a3c\u660e\u3092\u542b\u307f\u307e\u3059\u3002 public.json : \u516c\u958b\u3055\u308c\u305f\u5165\u51fa\u529b\u306e\u5024\u3092\u542b\u307f\u307e\u3059\u3002","title":"\u8a3c\u660e\u306e\u751f\u6210"},{"location":"getting-started/proving-circuits/#_3","text":"\u8a3c\u660e\u306e\u691c\u8a3c \u3092\u3059\u308b\u306b\u306f\u3001\u4ee5\u4e0b\u306e\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\u3002 snarkjs groth16 verify verification_key.json public.json proof.json \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u3001\u5148\u307b\u3069\u30a8\u30af\u30b9\u30dd\u30fc\u30c8\u3057\u305f verification_key.json \u3001 proof.json \u3001 public.json \u306e\u30d5\u30a1\u30a4\u30eb\u3092\u4f7f\u3063\u3066\u3001\u8a3c\u660e\u304c\u6709\u52b9\u304b\u3069\u3046\u304b\u3092\u30c1\u30a7\u30c3\u30af\u3057\u307e\u3059\u3002\u8a3c\u660e\u304c\u6709\u52b9\u306a\u5834\u5408\u3001\u30b3\u30de\u30f3\u30c9\u306f OK \u3092\u51fa\u529b\u3057\u307e\u3059\u3002 \u6709\u52b9\u306a\u8a3c\u660e\u306f\u3001\u56de\u8def\u3092\u6e80\u305f\u3059\u30b7\u30b0\u30ca\u30eb\u306e\u30bb\u30c3\u30c8\u3092\u77e5\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u8a3c\u660e\u3059\u308b\u3060\u3051\u3067\u306a\u304f\u3001\u4f7f\u7528\u3059\u308b\u516c\u958b\u5165\u51fa\u529b\u304c public.json \u30d5\u30a1\u30a4\u30eb\u306b\u8a18\u8ff0\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u3068\u4e00\u81f4\u3059\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u307e\u3059\u3002","title":"\u8a3c\u660e\u306e\u691c\u8a3c"},{"location":"getting-started/proving-circuits/#_4","text":"\ud83d\udc49 Ethereum\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3067\u8a3c\u660e\u3092\u691c\u8a3c \u3067\u304d\u308b Solidity\u691c\u8a3c\u5668 \u3092\u751f\u6210\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3067\u3059\u3002 \u307e\u305a\u3001Solidity\u306e\u30b3\u30fc\u30c9\u3092\u30b3\u30de\u30f3\u30c9\u3067\u751f\u6210\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 snarkjs zkey export solidityverifier multiplier2_0001.zkey verifier.sol \u3053\u306e\u30b3\u30de\u30f3\u30c9\u306f\u691c\u8a3c\u9375 multiplier2_0001.zkey \u3092\u53d7\u3051\u53d6\u308a\u3001Solidity\u306e\u30b3\u30fc\u30c9\u3092 verifier.sol \u3068\u3044\u3046\u30d5\u30a1\u30a4\u30eb\u306b\u51fa\u529b\u3057\u307e\u3059\u3002\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30b3\u30fc\u30c9\u3092\u53d6\u308a\u51fa\u3057\u3001Remix\u306b\u30ab\u30c3\u30c8\uff06\u30da\u30fc\u30b9\u30c8\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u30b3\u30fc\u30c9\u306b\u306f2\u3064\u306e\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002 Pairing \u3068 Verifier \u3067\u3059\u3002 Verifier \u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306e\u307f\u3092\u30c7\u30d7\u30ed\u30a4\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002 Rinkeby\u3001Kovan\u3001Ropsten\u306e\u3088\u3046\u306a\u30c6\u30b9\u30c8\u30cd\u30c3\u30c8\u3092\u6700\u521d\u306b\u4f7f\u7528\u3059\u308b\u3068\u3088\u3044\u3067\u3057\u3087\u3046\u3002JavaScript VM\u3092\u4f7f\u3046\u3053\u3068\u3082\u3067\u304d\u307e\u3059\u304c\u3001\u30d6\u30e9\u30a6\u30b6\u306b\u3088\u3063\u3066\u306f\u691c\u8a3c\u306b\u6642\u9593\u304c\u304b\u304b\u308a\u3001\u30da\u30fc\u30b8\u304c\u30d5\u30ea\u30fc\u30ba\u3059\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\u3002 Verifier \u306b\u306f verifyProof \u3068\u3044\u3046 view \u95a2\u6570\u304c\u3042\u308a\u3001\u8a3c\u660e\u3068\u5165\u529b\u304c\u6709\u52b9\u3067\u3042\u308b\u5834\u5408\u306b\u306e\u307f TRUE \u3092\u8fd4\u3057\u307e\u3059\u3002\u547c\u3073\u51fa\u3057\u3092\u5bb9\u6613\u306b\u3059\u308b\u305f\u3081\u306b\u3001 snarkJS \u3092\u4f7f\u7528\u3057\u3066\u3001\u5165\u529b\u306b\u3088\u3063\u3066\u30b3\u30fc\u30eb\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u751f\u6210\u3067\u304d\u307e\u3059\u3002 snarkjs generatecall \u30b3\u30de\u30f3\u30c9\u306e\u51fa\u529b\u3092Remix\u306e verifyProof \u30e1\u30bd\u30c3\u30c9\u306eparameters\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u30ab\u30c3\u30c8\uff06\u30da\u30fc\u30b9\u30c8\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3059\u3079\u3066\u304c\u3046\u307e\u304f\u3044\u3051\u3070\u3001\u3053\u306e\u30e1\u30bd\u30c3\u30c9\u306f TRUE \u3092\u8fd4\u3059\u306f\u305a\u3067\u3059\u3002\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u307b\u3093\u306e1\u30d3\u30c3\u30c8\u3092\u5909\u66f4\u3057\u3066\u307f\u308b\u3068\u3001\u691c\u8a3c\u53ef\u80fd\u306a FALSE \u3068\u306a\u308b\u3053\u3068\u304c\u308f\u304b\u308a\u307e\u3059\u3002","title":"\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3067\u306e\u691c\u8a3c"},{"location":"getting-started/testing-circuits/","text":"Testing circuits Writing a test Run our tests","title":"Testing circuits"},{"location":"getting-started/testing-circuits/#testing-circuits","text":"","title":"Testing circuits"},{"location":"getting-started/testing-circuits/#writing-a-test","text":"","title":"Writing a test"},{"location":"getting-started/testing-circuits/#run-our-tests","text":"","title":"Run our tests"},{"location":"getting-started/writing-circuits/","text":"\u56de\u8def\u306e\u8a18\u8ff0 circom \u3067\u306f\u3001\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u304c\u7b97\u8853\u56de\u8def\u3092\u5b9a\u7fa9\u3059\u308b \u5236\u7d04 \u3092\u5b9a\u7fa9\u3067\u304d\u307e\u3059\u3002\u3059\u3079\u3066\u306e\u5236\u7d04\u306f\u3001A\u3001B\u3001C\u304c\u30b7\u30b0\u30ca\u30eb\u306e\u7dda\u5f62\u7d50\u5408\u3067\u3042\u308b\u5834\u5408\u3001A*B + C = 0\u306e\u5f62\u3067\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093\u3002\u3053\u308c\u3089\u306e\u5f0f\u306e\u8a73\u7d30\u306b\u3064\u3044\u3066\u306f\u3001 \u3053\u3061\u3089 \u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002 circom \u3092\u4f7f\u3063\u3066\u4f5c\u308b\u7b97\u8853\u56de\u8def\u306f\u30b7\u30b0\u30ca\u30eb\u3092\u5bfe\u8c61\u306b\u3057\u3066\u6f14\u7b97\u3057\u307e\u3059\u30022\u3064\u306e\u5165\u529b\u30b7\u30b0\u30ca\u30eb\u3092\u5358\u7d14\u306b\u4e57\u7b97\u3057\u3001\u51fa\u529b\u30b7\u30b0\u30ca\u30eb\u3092\u751f\u6210\u3059\u308b\u6700\u521d\u306e\u56de\u8def\u3092\u5b9a\u7fa9\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002 pragma circom 2.0.0; /* \u3053\u306e\u56de\u8def\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u306f\u3001c\u304ca\u3068b\u306e\u639b\u3051\u7b97\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3059\u308b\u3082\u306e\u3067\u3059\u3002 */ template Multiplier2 () { // \u30b7\u30b0\u30ca\u30eb\u306e\u5ba3\u8a00 signal input a; signal input b; signal output c; // \u5236\u7d04 c <== a * b; } \u307e\u305a\u3001 pragma \u547d\u4ee4\u3067\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\u3053\u308c\u306f\u3001 pragma \u547d\u4ee4\u306e\u5f8c\u306b\u66f8\u304b\u308c\u305f\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u56de\u8def\u3067\u3042\u308b\u3053\u3068\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306e\u3082\u306e\u3067\u3059\u3002\u3082\u3057\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u7570\u306a\u308c\u3070\u30b3\u30f3\u30d1\u30a4\u30e9\u304c\u8b66\u544a\u3092\u6295\u3052\u307e\u3059\u3002 \u305d\u3057\u3066\u3001\u4e88\u7d04\u30ad\u30fc\u30ef\u30fc\u30c9 template \u3092\u4f7f\u3063\u3066\u3001 Multiplier2 \u3068\u3044\u3046\u65b0\u3057\u3044\u56de\u8def\u306e\u69cb\u6210\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\u3055\u3066\u3001\u305d\u306e \u30b7\u30b0\u30ca\u30eb \u3092\u5b9a\u7fa9\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002\u30b7\u30b0\u30ca\u30eb\u306b\u306f a , b , c \u306e\u3088\u3046\u306a\u8b58\u5225\u5b50\u3092\u4ed8\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u56de\u8def\u3067\u306f\u30012\u3064\u306e\u5165\u529b\u30b7\u30b0\u30ca\u30eb a , b \u3068\u51fa\u529b\u30b7\u30b0\u30ca\u30eb c \u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u6700\u5f8c\u306b <== \u3092\u4f7f\u3063\u3066\u3001 c \u306e\u5024\u304c a \u3068 b \u306e\u5024\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u7d50\u679c\u3067\u3042\u308b\u3053\u3068\u3092\u8a2d\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\u540c\u69d8\u306b\u3001\u6f14\u7b97\u5b50 ==> \u3092\u4f7f\u3063\u3066\u4f8b\u3048\u3070 a * b ==> c \u306e\u3088\u3046\u306b\u3067\u304d\u307e\u3059\u3002 \u5404\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u306f\u3001\u6700\u521d\u306b\u30b7\u30b0\u30ca\u30eb\u3092\u5ba3\u8a00\u3057\u3001\u305d\u306e\u5f8c\u306b\u95a2\u9023\u3059\u308b\u5236\u7d04\u3092\u5ba3\u8a00\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u76ee\u3057\u307e\u3057\u3087\u3046\u3002","title":"\u56de\u8def\u306e\u8a18\u8ff0"},{"location":"getting-started/writing-circuits/#_1","text":"circom \u3067\u306f\u3001\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u304c\u7b97\u8853\u56de\u8def\u3092\u5b9a\u7fa9\u3059\u308b \u5236\u7d04 \u3092\u5b9a\u7fa9\u3067\u304d\u307e\u3059\u3002\u3059\u3079\u3066\u306e\u5236\u7d04\u306f\u3001A\u3001B\u3001C\u304c\u30b7\u30b0\u30ca\u30eb\u306e\u7dda\u5f62\u7d50\u5408\u3067\u3042\u308b\u5834\u5408\u3001A*B + C = 0\u306e\u5f62\u3067\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093\u3002\u3053\u308c\u3089\u306e\u5f0f\u306e\u8a73\u7d30\u306b\u3064\u3044\u3066\u306f\u3001 \u3053\u3061\u3089 \u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002 circom \u3092\u4f7f\u3063\u3066\u4f5c\u308b\u7b97\u8853\u56de\u8def\u306f\u30b7\u30b0\u30ca\u30eb\u3092\u5bfe\u8c61\u306b\u3057\u3066\u6f14\u7b97\u3057\u307e\u3059\u30022\u3064\u306e\u5165\u529b\u30b7\u30b0\u30ca\u30eb\u3092\u5358\u7d14\u306b\u4e57\u7b97\u3057\u3001\u51fa\u529b\u30b7\u30b0\u30ca\u30eb\u3092\u751f\u6210\u3059\u308b\u6700\u521d\u306e\u56de\u8def\u3092\u5b9a\u7fa9\u3057\u3066\u307f\u307e\u3057\u3087\u3046\u3002 pragma circom 2.0.0; /* \u3053\u306e\u56de\u8def\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u306f\u3001c\u304ca\u3068b\u306e\u639b\u3051\u7b97\u3067\u3042\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3059\u308b\u3082\u306e\u3067\u3059\u3002 */ template Multiplier2 () { // \u30b7\u30b0\u30ca\u30eb\u306e\u5ba3\u8a00 signal input a; signal input b; signal output c; // \u5236\u7d04 c <== a * b; } \u307e\u305a\u3001 pragma \u547d\u4ee4\u3067\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\u3053\u308c\u306f\u3001 pragma \u547d\u4ee4\u306e\u5f8c\u306b\u66f8\u304b\u308c\u305f\u30b3\u30f3\u30d1\u30a4\u30e9\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u56de\u8def\u3067\u3042\u308b\u3053\u3068\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306e\u3082\u306e\u3067\u3059\u3002\u3082\u3057\u30d0\u30fc\u30b8\u30e7\u30f3\u304c\u7570\u306a\u308c\u3070\u30b3\u30f3\u30d1\u30a4\u30e9\u304c\u8b66\u544a\u3092\u6295\u3052\u307e\u3059\u3002 \u305d\u3057\u3066\u3001\u4e88\u7d04\u30ad\u30fc\u30ef\u30fc\u30c9 template \u3092\u4f7f\u3063\u3066\u3001 Multiplier2 \u3068\u3044\u3046\u65b0\u3057\u3044\u56de\u8def\u306e\u69cb\u6210\u3092\u5b9a\u7fa9\u3057\u307e\u3059\u3002\u3055\u3066\u3001\u305d\u306e \u30b7\u30b0\u30ca\u30eb \u3092\u5b9a\u7fa9\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002\u30b7\u30b0\u30ca\u30eb\u306b\u306f a , b , c \u306e\u3088\u3046\u306a\u8b58\u5225\u5b50\u3092\u4ed8\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3053\u306e\u56de\u8def\u3067\u306f\u30012\u3064\u306e\u5165\u529b\u30b7\u30b0\u30ca\u30eb a , b \u3068\u51fa\u529b\u30b7\u30b0\u30ca\u30eb c \u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u6700\u5f8c\u306b <== \u3092\u4f7f\u3063\u3066\u3001 c \u306e\u5024\u304c a \u3068 b \u306e\u5024\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u7d50\u679c\u3067\u3042\u308b\u3053\u3068\u3092\u8a2d\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\u540c\u69d8\u306b\u3001\u6f14\u7b97\u5b50 ==> \u3092\u4f7f\u3063\u3066\u4f8b\u3048\u3070 a * b ==> c \u306e\u3088\u3046\u306b\u3067\u304d\u307e\u3059\u3002 \u5404\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u306f\u3001\u6700\u521d\u306b\u30b7\u30b0\u30ca\u30eb\u3092\u5ba3\u8a00\u3057\u3001\u305d\u306e\u5f8c\u306b\u95a2\u9023\u3059\u308b\u5236\u7d04\u3092\u5ba3\u8a00\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u76ee\u3057\u307e\u3057\u3087\u3046\u3002","title":"\u56de\u8def\u306e\u8a18\u8ff0"},{"location":"more-circuits/more-basic-circuits/","text":"More basic circuits Extending our multiplier to three inputs Building on top of the 2-input multiplier, we can build a 3-input multiplier. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } //This circuit multiplies in1, in2, and in3. template Multiplier3 () { //Declaration of signals and components. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } component main = Multiplier3(); As expected, we first declare three input signals in1, in2, in3, and an output signal out and two instances of Multiplier2 . Instantiations of templates are done using the keyword component . We need an instance mult1 to multiply in1 and in2 . In order to assign the values of the input signals of mult1 we use the dot notation \".\" . Once mult1.in1 and mult1.in2 have their values set, then the value of mult1.out is computed. This value can be now used to set the input value of mult2 of the second instance of Multiplier2 to multiply in1*in2 and in3 obtaining the final result in1*in2*in3 . Finally, every execution starts from an initial main component defined as follows. component main {public [in1,in2,in3]} = Multiplier3(); Here, we indicate that the initial component for our first circom program is the circuit Multiplier3 which has three public signals: in1, in2 and in3 . In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public. Extending our multiplier to N inputs When defining a template, we can use parameters to build generic circuits. These parameters must have a known value at the moment of the instantiation of the template. Following up the previous example, we can implement an N-input multiplier, where N is a parameter. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } template MultiplierN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } // ... some more code (see below) } component main = MultiplierN(4); In addition to the parameter N , two well-known concepts appear in this fragment of code: arrays and integer variables . As we have seen for a 3-input multiplier, we need 3 input signals and 2 components of Multiplier2 . Then, for an N-input multiplier, we need an N-dimensional array of input signals and an \\(N-1\\) -dimensional array of components of Multiplier2 . We also need an integer variable i to instantiate each component comp[i] . Once this is done, we have to set the signals for each component as follows: comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } Similarly to Multiplier3 , each output signal of a component becomes one of the input signals of the next component. Finally, out is set as the output signal of the last component and its value will be in[0]*in[1]*...*in[N-1] . Finally, we define as main component a MultiplierN with N = 3 . component main {public [in]} = MultiplierN(3); pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals. signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template Multiplier3 () { //Declaration of signals. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } template MultiplierN (N){ //Declaration of signals. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } component main {public [in]} = MultiplierN(3); Writing a circuit for binary checks Let us build a circuit that checks if the input signal is binary. In case it is, the circuit returns an output signal with the same value than in . pragma circom 2.0.0; template binaryCheck () { // Declaration of signals. signal input in; signal output out; // Statements. in * (in-1) === 0; out <== in; } component main = binaryCheck(); After declaring the signals of the circuit, we use the operator === to introduce the constraint in * (in -1) = 0 . The solutions of this constraint are in = 0 and in = 1 . This means that the constraint has solution if and only if the input signal is binary. The instruction out <== in not only assigns the value of signal in to signal out , but it also adds the constraint out = in to the set of constraints that define the circuit. Then, when both constraints have solution, it is guaranteed that the output signal is binary. Sometimes, we only want to assign the value of a signal but not adding the corresponding constraint. In this case, we will use the operator <-- and --> . The differences between <--/--> and <==/==> are described here . Writing a logic gate AND with two inputs We are going to use the circuits Multiplier2 and binaryCheck to build a 2-gate logic AND. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template binaryCheck () { //Declaration of signals. signal input in; signal output out; //Statements. in * (in-1) === 0; out <== in; } template And2(){ //Declaration of signals and components. signal input in1; signal input in2; signal output out; component mult = Multiplier2(); component binCheck[2]; //Statements. binCheck[0] = binaryCheck(); binCheck[0].in <== in1; binCheck[1] = binaryCheck(); binCheck[1].in <== in2; mult.in1 <== binCheck[0].out; mult.in2 <== binCheck[1].out; out <== mult.out; } component main = And2(); Simplifying, the 2-gate AND circuit can be defined by the next constraints: in1 * (in1 - 1) = 0 , in2 * (in2 - 1) = 0 , out = in1 * in2 These constraints are satisfiable if and only if in1, in2 are binary signals. Consequently, out will also be binary. Extending our AND logic gate to N inputs Finally, let us build an N-gate logic AND using circuit Multiplier2 and binaryCheck . pragma circom 2.0.0; template binaryCheck () { /*Code from previous example*/ } template Multiplier2 () { /*Code from previous example*/ } template AndN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component mult[N-1]; component binCheck[N]; //Statements. for(var i = 0; i < N; i++){ binCheck[i] = binaryCheck(); binCheck[i].in <== in[i]; } for(var i = 0; i < N-1; i++){ mult[i] = Multiplier2(); } mult[0].in1 <== binCheck[0].out; mult[0].in2 <== binCheck[1].out; for(var i = 0; i < N-2; i++){ mult[i+1].in1 <== mult[i].out; mult[i+1].in2 <== binCheck[i+2].out; } out <== mult[N-2].out; } component main = AndN(4); This program is very similar to MultiplierN , but every signal involved in it is binary. It is important to highlight that we cannot use a (2N-1)-dimensional array to instantiate all the components since, every component of an array must be an instance of the same template with (optionally) different parameters.","title":"Basic circuits"},{"location":"more-circuits/more-basic-circuits/#more-basic-circuits","text":"","title":"More basic circuits"},{"location":"more-circuits/more-basic-circuits/#extending-our-multiplier-to-three-inputs","text":"Building on top of the 2-input multiplier, we can build a 3-input multiplier. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } //This circuit multiplies in1, in2, and in3. template Multiplier3 () { //Declaration of signals and components. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } component main = Multiplier3(); As expected, we first declare three input signals in1, in2, in3, and an output signal out and two instances of Multiplier2 . Instantiations of templates are done using the keyword component . We need an instance mult1 to multiply in1 and in2 . In order to assign the values of the input signals of mult1 we use the dot notation \".\" . Once mult1.in1 and mult1.in2 have their values set, then the value of mult1.out is computed. This value can be now used to set the input value of mult2 of the second instance of Multiplier2 to multiply in1*in2 and in3 obtaining the final result in1*in2*in3 . Finally, every execution starts from an initial main component defined as follows. component main {public [in1,in2,in3]} = Multiplier3(); Here, we indicate that the initial component for our first circom program is the circuit Multiplier3 which has three public signals: in1, in2 and in3 . In circom, all output signals of the main component are public (and cannot be made private), the input signals of the main component are private if not stated otherwise using the keyword public as above. The rest of signals are all private and cannot be made public.","title":"Extending our multiplier to three inputs"},{"location":"more-circuits/more-basic-circuits/#extending-our-multiplier-to-n-inputs","text":"When defining a template, we can use parameters to build generic circuits. These parameters must have a known value at the moment of the instantiation of the template. Following up the previous example, we can implement an N-input multiplier, where N is a parameter. pragma circom 2.0.0; template Multiplier2(){ /*Code from the previous example.*/ } template MultiplierN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } // ... some more code (see below) } component main = MultiplierN(4); In addition to the parameter N , two well-known concepts appear in this fragment of code: arrays and integer variables . As we have seen for a 3-input multiplier, we need 3 input signals and 2 components of Multiplier2 . Then, for an N-input multiplier, we need an N-dimensional array of input signals and an \\(N-1\\) -dimensional array of components of Multiplier2 . We also need an integer variable i to instantiate each component comp[i] . Once this is done, we have to set the signals for each component as follows: comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } Similarly to Multiplier3 , each output signal of a component becomes one of the input signals of the next component. Finally, out is set as the output signal of the last component and its value will be in[0]*in[1]*...*in[N-1] . Finally, we define as main component a MultiplierN with N = 3 . component main {public [in]} = MultiplierN(3); pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals. signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template Multiplier3 () { //Declaration of signals. signal input in1; signal input in2; signal input in3; signal output out; component mult1 = Multiplier2(); component mult2 = Multiplier2(); //Statements. mult1.in1 <== in1; mult1.in2 <== in2; mult2.in1 <== mult1.out; mult2.in2 <== in3; out <== mult2.out; } template MultiplierN (N){ //Declaration of signals. signal input in[N]; signal output out; component comp[N-1]; //Statements. for(var i = 0; i < N-1; i++){ comp[i] = Multiplier2(); } comp[0].in1 <== in[0]; comp[0].in2 <== in[1]; for(var i = 0; i < N-2; i++){ comp[i+1].in1 <== comp[i].out; comp[i+1].in2 <== in[i+2]; } out <== comp[N-2].out; } component main {public [in]} = MultiplierN(3);","title":"Extending our multiplier to N inputs"},{"location":"more-circuits/more-basic-circuits/#writing-a-circuit-for-binary-checks","text":"Let us build a circuit that checks if the input signal is binary. In case it is, the circuit returns an output signal with the same value than in . pragma circom 2.0.0; template binaryCheck () { // Declaration of signals. signal input in; signal output out; // Statements. in * (in-1) === 0; out <== in; } component main = binaryCheck(); After declaring the signals of the circuit, we use the operator === to introduce the constraint in * (in -1) = 0 . The solutions of this constraint are in = 0 and in = 1 . This means that the constraint has solution if and only if the input signal is binary. The instruction out <== in not only assigns the value of signal in to signal out , but it also adds the constraint out = in to the set of constraints that define the circuit. Then, when both constraints have solution, it is guaranteed that the output signal is binary. Sometimes, we only want to assign the value of a signal but not adding the corresponding constraint. In this case, we will use the operator <-- and --> . The differences between <--/--> and <==/==> are described here .","title":"Writing a circuit for binary checks"},{"location":"more-circuits/more-basic-circuits/#writing-a-logic-gate-and-with-two-inputs","text":"We are going to use the circuits Multiplier2 and binaryCheck to build a 2-gate logic AND. pragma circom 2.0.0; template Multiplier2(){ //Declaration of signals signal input in1; signal input in2; signal output out; //Statements. out <== in1 * in2; } template binaryCheck () { //Declaration of signals. signal input in; signal output out; //Statements. in * (in-1) === 0; out <== in; } template And2(){ //Declaration of signals and components. signal input in1; signal input in2; signal output out; component mult = Multiplier2(); component binCheck[2]; //Statements. binCheck[0] = binaryCheck(); binCheck[0].in <== in1; binCheck[1] = binaryCheck(); binCheck[1].in <== in2; mult.in1 <== binCheck[0].out; mult.in2 <== binCheck[1].out; out <== mult.out; } component main = And2(); Simplifying, the 2-gate AND circuit can be defined by the next constraints: in1 * (in1 - 1) = 0 , in2 * (in2 - 1) = 0 , out = in1 * in2 These constraints are satisfiable if and only if in1, in2 are binary signals. Consequently, out will also be binary.","title":"Writing a logic gate AND with two inputs"},{"location":"more-circuits/more-basic-circuits/#extending-our-and-logic-gate-to-n-inputs","text":"Finally, let us build an N-gate logic AND using circuit Multiplier2 and binaryCheck . pragma circom 2.0.0; template binaryCheck () { /*Code from previous example*/ } template Multiplier2 () { /*Code from previous example*/ } template AndN (N){ //Declaration of signals and components. signal input in[N]; signal output out; component mult[N-1]; component binCheck[N]; //Statements. for(var i = 0; i < N; i++){ binCheck[i] = binaryCheck(); binCheck[i].in <== in[i]; } for(var i = 0; i < N-1; i++){ mult[i] = Multiplier2(); } mult[0].in1 <== binCheck[0].out; mult[0].in2 <== binCheck[1].out; for(var i = 0; i < N-2; i++){ mult[i+1].in1 <== mult[i].out; mult[i+1].in2 <== binCheck[i+2].out; } out <== mult[N-2].out; } component main = AndN(4); This program is very similar to MultiplierN , but every signal involved in it is binary. It is important to highlight that we cannot use a (2N-1)-dimensional array to instantiate all the components since, every component of an array must be an instance of the same template with (optionally) different parameters.","title":"Extending our AND logic gate to N inputs"}]}